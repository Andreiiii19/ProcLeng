//*****************************************************************
// File:   cl.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
// Date:   julio 2023
// Coms:   compilar mediante "ant"
//*****************************************************************

options {
	IGNORE_CASE = true;
	COMMON_TOKEN_ACTION = true;
}

PARSER_BEGIN(alike)

package traductor;

//...

import lib.symbolTable.*;
import lib.attributes.*;
import lib.symbolTable.exceptions.*;
import java.util.ArrayList;
import lib.errores.*;
import lib.tools.SemanticFunctions;
import lib.tools.codeGeneration.*;
import static lib.symbolTable.Symbol.Types.*;

public class alike { 


	static SymbolTable st;
	static SemanticFunctions sf = new SemanticFunctions();
	static ArrayList<Token> tipoReturn = new ArrayList<Token>();

	static int linea = 0;

	private static void initSymbolTable() {
		boolean b;
		String[] palsRes = {
	    	"array","boolean","character","integer","procedure","if","then","elsif","else","end",
			"while","loop","begin","ref","of","is","not","put_line","put","return","and","or",
			"mod","skip_line","function","null","get","true","false","int2char","char2int"
		};

		st = new SymbolTable();

		st.insertReservedWords(palsRes);
	}

   public static void main(String[] args) {
	   alike parser = null;
	   initSymbolTable();
	   
	   try {
		   if(args.length == 0) {
			   parser = new alike(System.in);
		   }
		   else {
			   parser = new alike(new java.io.FileInputStream(args[0]));
		   }
		   //Programa es el símbolo inicial de la gramática
		   parser.Programa();
		   //...
		   System.out.println("***** Análisis terminado con éxito *****");
	   }
	   catch (java.io.FileNotFoundException e) {
		   System.err.println ("Fichero " + args[0] + " no encontrado.");
	   }
	   catch (TokenMgrError e) {
		   System.err.println("LEX_ERROR: " + e.getMessage());
	   }
	   catch (ParseException e) {
            System.err.println("PARSER_ERROR: " + e.getMessage());
        }
		catch (ErrorSemantico e) {
			System.err.println("SEMANTIC_ERROR: " + e.getMessage());
			System.err.println("***** Análisis parado por un error *****");
		}
	   //...
   }
}
PARSER_END(alike)

TOKEN_MGR_DECLS : {
	static void CommonTokenAction(Token token) {
		alike.linea = token.beginLine;
		// System.err.println("(" + token.beginLine + ", "
		// 			+ token.beginColumn + "): "+ alikeConstants.tokenImage[token.kind] + " " + token.image);
	}

}

SPECIAL_TOKEN : {
	< tCOMMENT: (<COMMENT>) >
}

TOKEN : {
	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|	< #CHAR: (~["\\"]) >
|	< #STRING: (~["\\","\""]|("\"\""))+ >
|	< #COMMENT: ("--")(~["\n"])*("\n") >
}

TOKEN : {
	< tBOOL: "boolean" >
|	< tCHAR: "character" >
|	< tINT: "integer" >
|	< tARRAY: "array" >
|	< tPROC: "procedure" >
|	< tIF:	"if" >
|	< tTHEN: "then" >
|	< tELSIF: "elsif" >
|	< tELSE: "else" >
|	< tENDIF: "end"(" ")+"if"> 
| 	< tEND: "end" >
|	< tWHILE: "while" >
|	< tLOOP: "loop" >
|	< tENDLOOP: "end loop" >
|	< tBEGIN: "begin" >
|	< tREF: "ref" >
|	< tOF: "of" >
|	< tIS: "is" >
|	< tNOT: "not" >
| 	< tPC: ";" >
|	< tPLINE: "put_line" >
|	< tPUT: "put" >
|	< tRETURN: "return" >
|	< tAP: "(" >
|	< tCP: ")" >
|	< tASIG: ":=" >
|	< tGE: ">=" >
|	< tLE: "<=" >
|	< tNEQ: "/=" >
|	< tEQ: "=" >
|	< tGT: ">" >
|	< tLS: "<" >
|	< tDP: ":" >
|	< tAND: "and" >
|	< tOR: "or" >
|	< tADD: "+" >
|	< tSUB: "-" >
|	< tDIV: "/" >
|	< tMUL: "*" >
|	< tCOMA: "," >
|	< tMOD: "mod" >
|	< tSKIP: "skip_line" >
|	< tFUNC : "function" >
|	< tNULL : "null" >
|	< tGET : "get" >
|	< tTRUE : "true" >
|	< tFALSE : "false" >
|	< tINT2CHAR : "int2char" >
|	< tCHAR2INT : "char2int" >
|	< tCONST_CHAR : ("'")(< CHAR >)("'") >
|	< tCONST_INT : (< DIGIT >)+ >
|	< tCONST_STRING : ("\"")(< STRING >)*("\"") >
| 	< tID: (< LETTER >| "_")+(< DIGIT >| "_" | < LETTER >)* > 
}

SKIP : 
{
	" "
|	"\t"
|	"\n"
|	"\r" 
}





//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void Programa():
{
	Token name;
	Attributes at = new Attributes();

	CodeBlock cprog=new CodeBlock(), cprocvar=new CodeBlock(),cprocfun=new CodeBlock(),cbloque=new CodeBlock();
} 
{
	{
		cprog = new CodeBlock();
		String etiq = CGUtils.newLabel();
		CGUtils.setLevel();
	}
	<tPROC>
	name = <tID>
	{
		
		try{
			name.image = name.image.toLowerCase();
			if(!st.isReservedWord(name.image))
			{
				st.insertReservedWord(name.image);

				SymbolProcedure S = new SymbolProcedure(name.image, at.parList);
				st.insertSymbol(S);
			}
			else
			{
				throw new ErrorSemantico("ID no valido. Es una palabra reservada");
			}
		} catch (AlreadyDefinedSymbolException ex)
		{
			throw new ErrorSemantico("Simbolo ya existente");
		}
	}
	(<tAP> parametros_formales(at, cprog) <tCP>)?
	<tIS>
	( declaracion_variables(cprocvar, false) )?
	( (declaracion_procs_funcs(cprocfun))+ )?
	<tBEGIN>
	instrucciones(cbloque)
	<tEND>
	<tPC> 
	{
		//System.err.println("Bloque " + name.image + " terminado \n" + st.toString());
		cprog.addInst(PCodeInstruction.OpCode.ENP, etiq);
		cprog.addBlock(cprocvar);
		cprog.addBlock(cprocfun);
		cprog.addComment("Comienzo main");
		cprog.addLabel(etiq);
		cprog.addBlock(cbloque);
		cprog.addComment("Fin main");
		cprog.addInst(PCodeInstruction.OpCode.LVP);
		System.out.println(cprog.toString());
	}
}

void declaracion_procedimiento(CodeBlock cBlock):
{
	Token name;
	Attributes att = new Attributes();

	CodeBlock cprog=new CodeBlock(),cparam = new CodeBlock(),cprocfun=new CodeBlock(),cprocvar=new CodeBlock(),cbloque=new CodeBlock();
	CGUtils.setLevel();
	String etiq = CGUtils.newLabel();
}
{
	name = cabecera_procedimiento(att, cparam)
	( declaracion_variables(cprocvar, false) )?
	( declaracion_procs_funcs(cprocfun) )?
	<tBEGIN>
	instrucciones(cbloque)
	<tEND>
	<tPC> 
	{
		//System.err.println("Bloque " + name.image + " terminado \n" + st.toString());
		st.removeBlock();
		cprog.addComment("Comienzo procedure "+name.image);
		cprog.addBlock(cparam);
		cprog.addBlock(cprocvar);
		cprog.addBlock(cprocfun);
		cprog.addLabel(etiq);
		cprog.addBlock(cbloque);
		cprog.addComment("Fin procedure "+name.image);
		cprog.addInst(PCodeInstruction.OpCode.CSF);
		cBlock.addBlock(cprog);
	}
}

void declaracion_funcion(CodeBlock cBlock):
{
	Attributes atType = new Attributes();
	Attributes atIsArray = new Attributes();
	Attributes atts = new Attributes();
	Token name;
	String etiq = CGUtils.newLabel();
	CodeBlock cprog=new CodeBlock(),cparam = new CodeBlock(), cprocvar=new CodeBlock(),cprocfun=new CodeBlock(),cbloque=new CodeBlock();
	CGUtils.setLevel();
}
{
	name = cabecera_funcion(atType,atIsArray,atts, cparam)
	{
		tipoReturn.add(name);
	}
	( declaracion_variables(cprocvar, false) )?
	( declaracion_procs_funcs(cprocfun) )?
	<tBEGIN>
	{
		
	}
	instrucciones(cbloque)
	<tEND>
	<tPC>
	{
		//System.err.println("Bloque " + name.image + " terminado \n"+ st.toString());
		st.removeBlock();
		if(atType.type == Symbol.Types.ARRAY)
		{
			throw new ErrorSemantico("No se permiten funciones con retorno de vectores");
		}

		tipoReturn.remove(tipoReturn.size()-1);

		cprog.addComment("Comienzo function "+name.image);
		cprog.addBlock(cparam);
		cprog.addBlock(cprocvar);
		cprog.addBlock(cprocfun);
		cprog.addLabel(etiq);
		cprog.addBlock(cbloque);
		cprog.addComment("Fin function "+name.image);
		cprog.addInst(PCodeInstruction.OpCode.CSF);
		cBlock.addBlock(cprog);
	}
}

void declaracion_procs_funcs(CodeBlock cBlock):
{}
{
	declaracion_procedimiento(cBlock)
	| declaracion_funcion(cBlock)
}

void instrucciones(CodeBlock cBlock):
{
	CodeBlock cInst = new CodeBlock();
}
{
	(instruccion(cInst)
	{
		cBlock.addBlock(cInst);
		cInst = new CodeBlock();
	}
	(";"))+
}


void declaracion_variables(CodeBlock cprocvar, Boolean esParametro):
{

}
{
	( declaracion_var(cprocvar, esParametro) ";")+
}

ArrayList<Symbol> declaracion_var(CodeBlock cprocvar, Boolean esParametro):
{
	Attributes atType = new Attributes();
	Attributes atIsArray = new Attributes();
	ArrayList<Token> tokens;
	ArrayList<Symbol> symbols = new ArrayList<Symbol>();
}
{
		tokens = lista_ids()
		<tDP>
		(	
		<tREF>
			{
				atType.parClass = Symbol.ParameterClass.REF;
			}
		)?
		tipo_variable(atType,atIsArray)
		{	
			if(atType.parClass==Symbol.ParameterClass.NONE)atType.parClass=Symbol.ParameterClass.VAL;
			for(Token t : tokens)
			{
				Symbol S = null;

				
				//System.out.println(atType.type + " " + atIsArray.type);
				if(atType.type == Symbol.Types.BOOL) S = new SymbolBool(t.image, atType.parClass);
				if(atType.type == Symbol.Types.CHAR) S = new SymbolChar(t.image, atType.parClass);
				if(atType.type == Symbol.Types.INT) S = new SymbolInt(t.image, atType.parClass);
				if(atType.type == Symbol.Types.ARRAY) 
				{
					if(atType.inicio>atType.fin)
					{
						throw new ErrorSemantico("Indices en declaración de array incoherentes");
					}

					S = new SymbolArray(t.image, atType.inicio,atType.fin,atIsArray.type,atType.parClass);
				}
				symbols.add(S);

				
				try {
					
					String name = "";
					Symbol.Types type = Symbol.Types.UNDEFINED;
					long inicio=0, fin = 0;
					if(S.type == Symbol.Types.ARRAY) {
						inicio = CGUtils.getLevel();
						S.dir = inicio;
						if(S.parClass != Symbol.ParameterClass.REF){
							for (int i = atType.inicio+1; i < atType.fin; i++) {
								fin = CGUtils.getLevel();
							}
							fin = CGUtils.getLevel();
						}
						name = "Array";
						SymbolArray symbolArrayInstance = (SymbolArray) S;
						type = symbolArrayInstance.baseType;
						if(!esParametro) cprocvar.addComment("- " + name + " variable \"" + t.image + "\", type " + type + ", size " + ( symbolArrayInstance.maxInd-symbolArrayInstance.minInd+1) +", level " + st.level + ", address [" + inicio + ":" + fin + "]!");
						else {
							if(S.parClass == Symbol.ParameterClass.REF) cprocvar.addComment("- " + name +" parameter \"" + t.image + "\", type " + type + ", size " + ( symbolArrayInstance.maxInd-symbolArrayInstance.minInd+1) + ", class " + S.parClass + ", level " + st.level + ", address ["+S.dir+"]!");
							else
							cprocvar.addComment("- " + name +" parameter \"" + t.image + "\", type " + type + ", size " + ( symbolArrayInstance.maxInd-symbolArrayInstance.minInd+1) + ", class " + S.parClass + ", level " + st.level + ", address [" + inicio + ":" + fin + "]!");
						}
					} else {
					S.dir = CGUtils.getLevel();
					if(!esParametro && S.type != Symbol.Types.ARRAY) cprocvar.addComment("- Simple variable \"" + t.image + "\", type " + type + ", level " + st.level + ", address [" + S.dir + "]!");
					else cprocvar.addComment("- Simple parameter \"" + t.image + "\", type " + type + ", class " + S.parClass + ", level " + st.level + ", address [" + S.dir + "]!");
					}
					st.insertSymbol(S);
				} catch (AlreadyDefinedSymbolException e)
				{
					throw new ErrorSemantico("Error semantico. Simbolo ya existente");
				}
			}

			return symbols;
		}
}

Attributes lista_componentes():
{
	Token t;
	Attributes att = new Attributes();
	Attributes at = new Attributes();
	Symbol S = null;
	CodeBlock cBlock = new CodeBlock();
}
{
	(
		t=<tID>
			(<tAP>expresion(at, cBlock)<tCP>)?
			{
				t.image = t.image.toLowerCase();
				if(!st.isReservedWord(t.image))
				{
					try
					{
						t.image = t.image.toLowerCase();
						S = st.getSymbol(t.image);
						sf.cambiarTipos(at, S);
						sf.asignar_valores(att,at,t.image,S.type, S.parClass, st.level,false);
						//sf.checkPrimarioIds(at);
						at = new Attributes();	
					}
					catch(SymbolNotFoundException ex)
					{
						throw new ErrorSemantico(t.image + " no existe.");
					}
				}
				else
				{
					throw new ErrorSemantico("ID no valido. Es una palabra reservada");
				}
			}
	)
	(
		<tCOMA>
		t=<tID>
			(<tAP>expresion(at, cBlock)<tCP>)?
			{
				t.image = t.image.toLowerCase();
				if(!st.isReservedWord(t.image))
				{
					try
					{
						t.image = t.image.toLowerCase();
						S = st.getSymbol(t.image);
						sf.cambiarTipos(at, S);
						sf.asignar_valores(att,at,t.image,S.type, S.parClass, st.level,false);
						//sf.checkPrimarioIds(at);
						at = new Attributes();	
					}
					catch(SymbolNotFoundException ex)
					{
						throw new ErrorSemantico(t.image + " no existe.");
					}
				}
				else
				{
					throw new ErrorSemantico("ID no valido. Es una palabra reservada");
				}
			}
	)*
		{
			//System.err.println("Lista de ids ");
			return att;
		}
}

ArrayList<Token> lista_ids():
{
	ArrayList<Token> tokens = new ArrayList<Token>();
	Token t;
}
{
	(
		t=<tID>
			{
				t.image = t.image.toLowerCase();
				if(!st.isReservedWord(t.image))
				{
					tokens.add(t);
				}
				else
				{
					throw new ErrorSemantico("ID no valido. Es una palabra reservada");
				}

			}
	)
	(
		<tCOMA>
		t=<tID>
			{
				t.image = t.image.toLowerCase();
				if(!st.isReservedWord(t.image)) tokens.add(t);
				else throw new ErrorSemantico("ID no valido. Es una palabra reservada");
			}
	)*
		{
			//System.err.println("Lista de ids ");
			return tokens;
		}
}

void lista_ids_o_string_o_inv(Attributes att, CodeBlock cBlock):
{
	Attributes at = new Attributes();
}
{
	expresion(at, cBlock)
	{
		att.atts.add(at.clone());
		switch (at.type){
			case STRING:
				String code = at.code;
				if (code.startsWith("\"") && code.endsWith("\"")) {
					code = code.substring(1, code.length() - 1);
				}
				if (code.contains("\"\"")) {
					code = code.replace("\"\"", "\"");
				}
				cBlock.addComment("- Write STRING \"" + code + "\".");
				for(char c: code.toCharArray()) {
					cBlock.addComment("- Write CHAR \"" + c + "\".");
					cBlock.addInst(PCodeInstruction.OpCode.STC, (int)c);
					cBlock.addInst(PCodeInstruction.OpCode.WRT, 0);
				}
				break;
			
		}

		at = new Attributes();
	}
	(<tCOMA> expresion(at, cBlock) 
	{
		att.atts.add(at.clone());
		switch (at.type){
			case STRING:
				String code = at.code;
				if (code.startsWith("\"") && code.endsWith("\"")) {
					code = code.substring(1, code.length() - 1);
				}
				if (code.contains("\"\"")) {
					code = code.replace("\"\"", "\"");
				}
				cBlock.addComment("- Write STRING \"" + code + "\".");
				for(char c: code.toCharArray()) {
					cBlock.addComment("- Write CHAR \"" + c + "\".");
					cBlock.addInst(PCodeInstruction.OpCode.STC, (int)c);
					cBlock.addInst(PCodeInstruction.OpCode.WRT, 0);
				}
				break;
			case CHAR:
				if(!at.code.contains("int2char"))
				{
					cBlock.addComment("- Write CHAR \"" + at.code + "\".");
					cBlock.addInst(PCodeInstruction.OpCode.STC, (int)at.code.charAt(0));
					cBlock.addInst(PCodeInstruction.OpCode.WRT, 0);
				} else {
					cBlock.addComment("- Write CHAR \"" + at.code + "\".");
				}
				break;
				
		}

		at = new Attributes();

	})*
	{
		att.type = att.atts.get(0).type;
		
	}
}


Token cabecera_procedimiento(Attributes att, CodeBlock cprog):
{
	Token name;
}
{
	<tPROC>
	name = <tID>
	{
		try {
			name.image = name.image.toLowerCase();
			Symbol S = new SymbolProcedure(name.image,att.parList);
			st.insertSymbol(S);
			st.insertBlock();
		}catch (AlreadyDefinedSymbolException ex)
		{
			throw new ErrorSemantico("Error semantico. Simbolo ya existente");
		}
	}
	(<tAP> 
	parametros_formales(att, cprog)
	<tCP>)?
	<tIS>
	{
		return name;
	}
}

Token cabecera_funcion(Attributes atType,Attributes atIsArray,Attributes atts, CodeBlock cprog):
{
	Token name;
	SymbolFunction S = null;
}
{
	<tFUNC>
	name = <tID>
	{
		try{ 
			name.image = name.image.toLowerCase();
			S = new SymbolFunction(name.image,atts.parList,atType.type);
			st.insertSymbol(S);
			st.insertBlock();
		} catch (AlreadyDefinedSymbolException ex)
		{
			throw new ErrorSemantico("Error semantico. Simbolo ya existente");
		}
		
	}
	(<tAP> parametros_formales(atts, cprog) <tCP>)?
	<tRETURN>
	tipo_variable_simple(atType)
	<tIS>
	{
		S.returnType = atType.type;
		return name;
	}
}

void parametros_formales(Attributes att, CodeBlock cprog): 
{
	ArrayList<Symbol> symbols;
	CodeBlock cprocvar = new CodeBlock();
}
{
	symbols = declaracion_var(cprocvar, true)
	{
		// try {
			for(Symbol S : symbols)
			{
				att.parList.add(S);
		// 		st.insertSymbol(S);
			}
			cprog.addBlock(cprocvar);
			cprocvar = new CodeBlock();
		// } catch (AlreadyDefinedSymbolException ex)
		// {
		// 	System.err.println("Error semantico. Simbolo ya existente");
		// }
	}
	(<tPC> 
	symbols = declaracion_var(cprocvar, true)
	{
		for(Symbol S : symbols)
		{
			att.parList.add(S);
			// st.insertSymbol(S);
		}
		cprog.addBlock(cprocvar);
	}
	)*
}


void instruccion(CodeBlock cBlock) :
{
	Attributes att = new Attributes();	
	CodeBlock cInst = new CodeBlock();
}
{
	(	inst_leer(att,cInst)
	|   inst_saltar_linea(att,cInst)
	|	inst_escribir(att,cInst)
	|   inst_escribir_linea(att,cInst)
	|   inst_invocacion_o_asignacion(att,cInst)
	|   inst_if(att,cInst)
	|   inst_while(att,cInst)
	|   inst_return(att,cInst)
	|   inst_null(att,cInst)
	)
	{
		cBlock.addBlock(cInst);
	}
}

void inst_leer(Attributes att,CodeBlock cBlock):
{

}
{
	<tGET> 
	<tAP> att = lista_componentes() <tCP>
	{
		sf.check_inst_leer(st,att);
	}
	{	
		for (Attributes a : att.atts)
		{	
			try{
				Symbol S = st.getSymbol(a.code);
				cBlock.addComment("- Get simple variable/parameter \"" + a.code + "\".");
				cBlock.addInst(PCodeInstruction.OpCode.SRF, (st.level - S.nivel), (int)S.dir);
				cBlock.addInst(PCodeInstruction.OpCode.RD, a.type== Symbol.Types.INT?1:0);
			} catch (SymbolNotFoundException ex)
			{
				throw new ErrorSemantico(a.code + " no existe.");
			}
		}
	}
}

void inst_saltar_linea(Attributes att,CodeBlock cBlock):
{}{<tSKIP>
	{
		String et = CGUtils.newLabel();
		cBlock.addLabel(et);
		long dir = CGUtils.getLevel();
		cBlock.addInst(PCodeInstruction.OpCode.SRF, 0, (int)dir);
		cBlock.addInst(PCodeInstruction.OpCode.RD, 0);
		cBlock.addInst(PCodeInstruction.OpCode.SRF, 0, (int)dir);
		cBlock.addInst(PCodeInstruction.OpCode.DRF);
		cBlock.addInst(PCodeInstruction.OpCode.STC, 10);
		cBlock.addInst(PCodeInstruction.OpCode.EQ);
		cBlock.addInst(PCodeInstruction.OpCode.JMF, et);
	}
}

void inst_escribir(Attributes att,CodeBlock cBlock):
{}
{
	<tPUT> <tAP> lista_ids_o_string_o_inv(att, cBlock)  <tCP>
	{
		sf.check_inst_escribir(st,att);
		cBlock.addComment("- Write CR/LF");
		cBlock.addInst(PCodeInstruction.OpCode.STC, 13);
		cBlock.addInst(PCodeInstruction.OpCode.WRT, 0);
		cBlock.addInst(PCodeInstruction.OpCode.STC, 10);
		cBlock.addInst(PCodeInstruction.OpCode.WRT, 0);
		//System.err.println("Expresion: " + att);
	}
}

void inst_escribir_linea(Attributes att,CodeBlock cBlock):
{}
{
	<tPLINE> ((<tAP> lista_ids_o_string_o_inv(att, cBlock) <tCP>))?
	{
		if(att.atts.size()>0)
		{
			sf.check_inst_escribir(st,att);
		}
		cBlock.addComment("- Write CR/LF");
		cBlock.addInst(PCodeInstruction.OpCode.STC, 13);
		cBlock.addInst(PCodeInstruction.OpCode.WRT, 0);
		cBlock.addInst(PCodeInstruction.OpCode.STC, 10);
		cBlock.addInst(PCodeInstruction.OpCode.WRT, 0);
	}
}

void inst_invocacion_o_asignacion(Attributes att,CodeBlock cBlock):
{
	Attributes at = new Attributes();
	Attributes at2 = new Attributes();
	Token t;
}
{
	t = <tID>
	(<tAP> ((function_call(at2)))
	<tCP>)? 
	{
		try {
			t.image = t.image.toLowerCase();
			Symbol S = st.getSymbol(t.image);
			//System.err.println("Tipo de la funcion: " + at2);	
			sf.cambiarTipos(at2, S);
			//System.err.println("Tipo de la funcion: " + at2);	
			sf.asignar_valores(att,at2,t.image,S.type, S.parClass, st.level,false);
			if(at2.type==Symbol.Types.ARRAY)
			{
				throw new ErrorSemantico("No se puede realizar una asignación a un array entero");
			}
			sf.checkTypeFunctionCall(at2);
		} catch (SymbolNotFoundException ex)
		{
			throw new ErrorSemantico(t.image + " no existe.");
		}
	} 	
	(<tASIG> expresion(at, cBlock) 
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		sf.checkTypesAsignacion(at,at2);
		at = new Attributes();
		at2 = new Attributes();
	}
	)?
	{
	}
}

void inst_if(Attributes att,CodeBlock cBlock):
{
	Attributes at = new Attributes();
	CodeBlock cbloque=new CodeBlock();
}
{
	<tIF> expresion(at, cBlock)
	{
		if(at.type==Symbol.Types.ARRAY)
		{
			Attributes aux = at.atts.get(0);
			for(int i=0; i<6 && aux.atts.size()>0; i++)
			{
				aux = aux.atts.get(0);	
			}
			if(aux.type!=Symbol.Types.INT)
			{
				throw new ErrorSemantico("No puedes comparar un array entero con un booleano");
			}
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("El array tienen que devolver un booleano: "+at.type);
			}
		} 
		else if(at.type== Symbol.Types.FUNCTION)
		{
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("La funcion tienen que devolver un booleano: "+at.type);
			}
		}
		else if(at.type!=Symbol.Types.BOOL)
		{
			throw new ErrorSemantico("Solo se admiten expresiones booleanas: "+at.type);
		}
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
	}
	<tTHEN> instrucciones(cbloque) ((<tELSIF> expresion(at, cBlock)
	{
		if(at.type==Symbol.Types.ARRAY)
		{
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("El array tienen que devolver un booleano: "+at.type);
			}
		} 
		else if(at.type== Symbol.Types.FUNCTION)
		{
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("La funcion tienen que devolver un booleano: "+at.type);
			}
		}
		else if(at.type!=Symbol.Types.BOOL)
		{
			throw new ErrorSemantico("Solo se admiten expresiones booleanas: "+at.type);
		}
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();

	}
	<tTHEN> instrucciones(cbloque))* (<tELSE> instrucciones(cbloque))?) <tENDIF>
} 

void inst_while(Attributes att,CodeBlock cBlock):
{
	Attributes at = new Attributes();

	CodeBlock cbloque=new CodeBlock();
}
{
	<tWHILE> expresion(at, cBlock)
	{
		if(at.type==Symbol.Types.ARRAY || at.type==Symbol.Types.FUNCTION)
		{
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("Solo se admiten expresiones booleanas: "+at.type);
			}
		}
		else if(at.type!=Symbol.Types.BOOL)
		{
			throw new ErrorSemantico("Solo se admiten expresiones booleanas: "+at.type);
		}
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
	}
	<tLOOP> instrucciones(cbloque) <tENDLOOP>
	{
		//System.err.println("Expresion while condicion: " + att);
	}
}

void inst_return(Attributes att,CodeBlock cBlock):{
	Attributes at = new Attributes();
}
{
	<tRETURN> expresion(at, cBlock)
	{
		try{
			Symbol S = st.getSymbol(tipoReturn.get(tipoReturn.size()-1).image);
			sf.add_to_atts(att,at);
			
			if(S.type != Symbol.Types.FUNCTION){
				throw new ErrorSemantico("Solo se puede hacer return en funciones");
			} 
			if(at.type == Symbol.Types.FUNCTION)
			{
				if(at.extraType!=((SymbolFunction)S).returnType)
				{
					throw new ErrorSemantico("Error de tipos en return");
				}
			} 
			else if(at.type != ((SymbolFunction)S).returnType)
			{

				throw new ErrorSemantico("Error de tipos en return");
			}
			
			at = new Attributes();
		} catch(SymbolNotFoundException ex) {
			throw new ErrorSemantico("Error semantico. Funcion no encontrada");
		}
	}
}

void inst_null(Attributes att,CodeBlock cBlock):{}{<tNULL>	}


void expresion(Attributes att, CodeBlock cBlock):
{
	Boolean esBool = false; 
	Attributes at = new Attributes();
}
{
    relacion(at, cBlock)
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
	}
	( ((<tAND>) 
	{
		att.type = Symbol.Types.BOOL;
		esBool = true;
	}
	relacion(at, cBlock) 
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
	}
	)+
	|
	((<tOR>) 
	{
		att.type = Symbol.Types.BOOL;
		esBool = true;
	}
	relacion(at, cBlock) 
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
	}
	)+ )?
	{
		// ( 2+3+4) + 5 + (2+3)
		// Expresion
		//  (2+3+4)
		//   5
		//  (2+3)
		if(esBool)
		{
			 for(Attributes a : att.atts)
			 {
				//System.err.println(a.type);
				if(a.type == Symbol.Types.FUNCTION || a.type == Symbol.Types.ARRAY){
					if(a.extraType!=Symbol.Types.BOOL)
					{
						throw new ErrorSemantico("Error de tipos");
					}
					if(a.type == Symbol.Types.ARRAY){
						Attributes aux = a.atts.get(0);
						for(int i=0; i<5 && aux.atts.size()>0; i++)
						{
							aux = aux.atts.get(0);	
							//System.err.println(aux.type);
						}
						if(aux.type!=Symbol.Types.INT)
						{
							throw new ErrorSemantico("No puedes comparar un array entero con un booleano");
						}
					}
				} else{
					if(a.type!=Symbol.Types.BOOL)
					{
						throw new ErrorSemantico("Error de tipos");
					}
				}
			 }
			 //System.out.println();
		}
		
	}
}

void relacion(Attributes att, CodeBlock cBlock):
{
	//Attributes atTypes = new Attributes();
	Boolean tieneOpInts = null;
	Attributes at = new Attributes();
}
{
    expresion_simple(at, cBlock)
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
	}
 	( tieneOpInts = operador_relacional()
	expresion_simple(at, cBlock)
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		
	} 
	)? 
	{
		if(tieneOpInts!=null)
		{
			att.type = Symbol.Types.BOOL;
			if(tieneOpInts)
			{
				//System.err.println("Operador relacional: " + att);
				for(Attributes a : att.atts)
			 	{
					if (a.type==Symbol.Types.ARRAY || a.type==Symbol.Types.FUNCTION)
					{
						if(a.extraType!=Symbol.Types.INT)
						{
							throw new ErrorSemantico("Error de tipos. Se esperaban integers en relacion: "+a.type);
						}
					} else if(a.type!=Symbol.Types.INT)
			 		{
			 			throw new ErrorSemantico("Error de tipos. Se esperaban integers en relacion: "+a.type);
			 		}
			 	}
			} else {
				if(at.type != Symbol.Types.UNDEFINED) 
				{
					Attributes a2 = att.atts.get(att.atts.size()-2);
					if(a2.type == Symbol.Types.FUNCTION || a2.type == Symbol.Types.ARRAY)
					{
						if(a2.extraType!=at.type)
						{
							throw new ErrorSemantico("Error de tipos. Se esperaban el mismo tipo en relacion: " + a2.extraType + " y "+ at.type);
						}
					} else if(at.type == Symbol.Types.FUNCTION || at.type == Symbol.Types.ARRAY)
					{
						if(a2.type!=at.extraType)
						{
							throw new ErrorSemantico("Error de tipos. Se esperaban el mismo tipo en relacion: " + a2.type + " y "+ at.extraType);
						}
					}
					else if(a2.type!=at.type)
					{
						throw new ErrorSemantico("Error de tipos. Se esperaban el mismo tipo en relacion: " + a2.type + " y "+ at.type);
					}
				}
			}
		}
	}
}

Boolean operador_relacional():
{
	
}
{    
	<tEQ>    {return false;}// Char,bool,int
	| <tLS>  {return true;}// Int
	| <tGT>  {return true;}// Int
	| <tLE>  {return true;}// Int
	| <tGE>  {return true;}// Int
	| <tNEQ> {return false;}// Char,bool,int
}

void expresion_simple(Attributes att, CodeBlock cBlock):
{
	boolean esInt=false;
	Attributes at = new Attributes();
}
{
	(( <tADD> |	<tSUB> )
	{
		esInt=true;att.type=Symbol.Types.INT;
	})? 
    termino(at, cBlock)
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at); 
		at = new Attributes();
	}
	( ( <tADD> | <tSUB> ) 
	termino(at, cBlock) 
	{	
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
		att.type = Symbol.Types.INT;
		//System.err.println("Expresion simple: " + att);
		for(Attributes a : att.atts)
		{
			if(a.type == Symbol.Types.FUNCTION || a.type == Symbol.Types.ARRAY)
			{
				if(a.extraType!=Symbol.Types.INT)
				{
					throw new ErrorSemantico("Error de tipos. Se esperaban integers en expresion simple: " + a.type);
				}
			} else if(a.type!=Symbol.Types.INT)
			{
				throw new ErrorSemantico("Error de tipos. Se esperaban integers en expresion simple: " + a.type);
			}
		}
	})*
}

void termino(Attributes att, CodeBlock cBlock):
{
	Attributes at = new Attributes();
}
{
    factor(at, cBlock) 
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
	}
	( operador_multiplicativo() factor(at, cBlock)
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		att.type = Symbol.Types.INT;
		at = new Attributes();
		
		for(Attributes a : att.atts)
		{
			if(a.type == Symbol.Types.FUNCTION || a.type == Symbol.Types.ARRAY)
			{
				if(a.extraType!=Symbol.Types.INT)
				{
					throw new ErrorSemantico("Error de tipos. Se esperaban integers en termino: " + att.atts.get(0).type);
				}
			} else if(a.type!=Symbol.Types.INT)
			{
				throw new ErrorSemantico("Error de tipos. Se esperaban integers en termino: " + att.atts.get(0).type);
			}
		}
	}
	
	)*
}

void operador_multiplicativo():
{}
{
    <tMUL> | <tMOD> | <tDIV>
}

void factor(Attributes att, CodeBlock cBlock):
{
	Attributes at = new Attributes();
}
{
    primario(at, cBlock) 
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
		
	}

|   <tNOT>  primario(at, cBlock)
	{
		att.type = Symbol.Types.BOOL;
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		if(at.type == Symbol.Types.ARRAY)
		{
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("El array tienen que devolver un booleano: "+at.type);
			}
		} 
		else if(at.type == Symbol.Types.FUNCTION)
		{
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("La funcion tienen que devolver un booleano: "+at.type);
			}
		}
		else if(at.type!=Symbol.Types.BOOL)
		{
			throw new ErrorSemantico("Solo se admiten expresiones booleanas: "+at.type);
		}
		at = new Attributes();
	}
}

void primario(Attributes att, CodeBlock cBlock) :
{ 
	Attributes at = new Attributes();

	Token t;
	Symbol S;
}
{
	<tAP> expresion(at, cBlock) <tCP> 
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
	}
|   <tINT2CHAR> <tAP> expresion(at, cBlock) <tCP> 
	{
		if(at.type!=Symbol.Types.INT)
		{
			throw new ErrorSemantico("int2char solo acepta enteros");
		}
		if(at.atts.size()!=1){
			throw new ErrorSemantico("int2char solo acepta un entero");
		}
		if(at.esConstante) {
			cBlock.addInst(PCodeInstruction.OpCode.STC, Integer.parseInt(at.code));
		}
		String etiq1 = CGUtils.newLabel();
		String etiq2 = CGUtils.newLabel();
		cBlock.addComment("- check 0 <= int <= 255");
		cBlock.addInst(PCodeInstruction.OpCode.DUP);
		cBlock.addInst(PCodeInstruction.OpCode.STC, 0);
		cBlock.addInst(PCodeInstruction.OpCode.GTE);
		cBlock.addInst(PCodeInstruction.OpCode.JMF, etiq1);
		cBlock.addInst(PCodeInstruction.OpCode.STC, 255);
		cBlock.addInst(PCodeInstruction.OpCode.LTE);
		cBlock.addInst(PCodeInstruction.OpCode.JMF, etiq1);
		cBlock.addInst(PCodeInstruction.OpCode.JMP, etiq2);
		cBlock.addLabel(etiq1);
		String code = "Value invalid for int2char in line ("+ linea + ").";
				if (code.startsWith("\"") && code.endsWith("\"")) {
					code = code.substring(1, code.length() - 1);
				}
				if (code.contains("\"\"")) {
					code = code.replace("\"\"", "\"");
				}
				cBlock.addComment("- Write STRING \"" + code + "\".");
				for(char c: code.toCharArray()) {
					cBlock.addComment("- Write CHAR \"" + c + "\".");
					cBlock.addInst(PCodeInstruction.OpCode.STC, (int)c);
					cBlock.addInst(PCodeInstruction.OpCode.WRT, 0);
				}
		cBlock.addInst(PCodeInstruction.OpCode.LVP);
		cBlock.addLabel(etiq2);
		cBlock.addInst(PCodeInstruction.OpCode.WRT, 0);
		sf.asignar_valores(att,at,at.code,Symbol.Types.CHAR, Symbol.ParameterClass.VAL, st.level, true);
		sf.heredar_valores(att,at);
	}
|   <tCHAR2INT> <tAP> expresion(at, cBlock) <tCP> 
	{
		if(at.type!=Symbol.Types.CHAR)
		{
			throw new ErrorSemantico("char2int solo acepta caracteres");
		}
		if(at.atts.size()!=1){
			throw new ErrorSemantico("char2int solo acepta un caracter");
		}
		sf.asignar_valores(att,at,"char2int(" + at.code + ")",Symbol.Types.INT, Symbol.ParameterClass.VAL, st.level,true);
		sf.heredar_valores(att,at);
	}
|   t=<tID> (<tAP> (function_call(at)) <tCP> )?  
	{
		try
		{
			t.image = t.image.toLowerCase();
			S = st.getSymbol(t.image);
			sf.cambiarTipos(at, S);
			sf.asignar_valores(att,at,t.image,S.type, S.parClass, st.level,false);
			sf.checkPrimarioIds(at);
			at = new Attributes();			
		}
		catch(SymbolNotFoundException ex)
		{
			throw new ErrorSemantico(t.image + " no existe.");
		}

	}
|   ("-")? t= <tCONST_INT> 
    {
		cBlock.addInst(PCodeInstruction.OpCode.STC, Integer.parseInt(t.image));
		sf.asignar_valores(att,at,t.image,Symbol.Types.INT, Symbol.ParameterClass.VAL, st.level,true);
	}
|   t= <tCONST_CHAR> 
	{
		String charWithoutQuotes = t.image.substring(1, t.image.length() - 1);
		System.out.println("Char: " + charWithoutQuotes);
		char charValue = charWithoutQuotes.charAt(0);
		cBlock.addInst(PCodeInstruction.OpCode.STC, (int) charValue);
		sf.asignar_valores(att,at,t.image,Symbol.Types.CHAR, Symbol.ParameterClass.VAL, st.level,true);
	}
|   t= <tCONST_STRING> 
	{
		// cBlock.addInst(PCodeInstruction.OpCode.STC, Integer.parseInt(t.image));
		sf.asignar_valores(att,at,t.image,Symbol.Types.STRING, Symbol.ParameterClass.VAL, st.level,true);
	}
|   t= <tTRUE>	
	{
		cBlock.addInst(PCodeInstruction.OpCode.STC, 1);
		sf.asignar_valores(att,at,"true",Symbol.Types.BOOL, Symbol.ParameterClass.VAL, st.level,true);
	}
|   t= <tFALSE> 
	{
		cBlock.addInst(PCodeInstruction.OpCode.STC, 0);
		sf.asignar_valores(att,at,"false",Symbol.Types.BOOL, Symbol.ParameterClass.VAL, st.level,true);
	}
}


void function_call(Attributes att) :
{ 
	Attributes at = new Attributes();
	CodeBlock cBlock = new CodeBlock();
}
{
 ( expresion(at, cBlock)
 {
	sf.add_to_atts(att,at);
	sf.heredar_valores(att,at);
	at = new Attributes();
 } 
 ((<tCOMA>) expresion(at, cBlock)
 {
	sf.add_to_atts(att,at);
	sf.heredar_valores(att,at);
	at = new Attributes();
}
)* 
 ) 
 {
	
 }
}


void tipo_variable(Attributes atTypes, Attributes atIsArray):
{ 
	Token i;
	Boolean esNegativo = false;
}
{
	< tARRAY >
	<tAP>
	("-" {esNegativo=true;})? i = < tCONST_INT >
		{
			if(esNegativo)	atTypes.inicio = -Integer.parseInt(i.image);
			else atTypes.inicio = Integer.parseInt(i.image);
			esNegativo = false;
			
			//at.parList.add(new Symbol(i.image,Symbol.Types.INT));
			
		}
	("..")
	("-"{esNegativo=true;})? i = < tCONST_INT >
		{
			if(esNegativo)	atTypes.fin = -Integer.parseInt(i.image);
			else atTypes.fin = Integer.parseInt(i.image);
			// at.parList.add(new Symbol(i.image,Symbol.Types.INT));
			atTypes.type = Symbol.Types.ARRAY;
			esNegativo = false;
		}
	<tCP>
	 <tOF> tipo_variable_simple(atIsArray)
|   tipo_variable_simple(atTypes)
}

void tipo_variable_simple(Attributes at):
{

}
{
		< tBOOL > 
			{
				at.type = Symbol.Types.BOOL;
			}
	|	< tCHAR >
			{
				at.type = Symbol.Types.CHAR;
			}
	|	< tINT >
			{
				at.type = Symbol.Types.INT;
			}
}

