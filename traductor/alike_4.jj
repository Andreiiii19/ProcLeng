//*****************************************************************
// File:   cl.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
// Date:   julio 2023
// Coms:   compilar mediante "ant"
//*****************************************************************

options {
	IGNORE_CASE = true;
	COMMON_TOKEN_ACTION = true;
}

PARSER_BEGIN(alike)

package traductor;

//...

import lib.symbolTable.*;
import lib.attributes.*;
import lib.symbolTable.exceptions.*;
import java.util.ArrayList;
import lib.errores.*;
import lib.tools.SemanticFunctions;
import lib.tools.codeGeneration.*;

public class alike { 


	static SymbolTable st;
	static SemanticFunctions sf = new SemanticFunctions();
	static ArrayList<Token> tipoReturn = new ArrayList<Token>();

	private static void initSymbolTable() {
		boolean b;
		String[] palsRes = {
	    	"array","boolean","character","integer","procedure","if","then","elsif","else","end",
			"while","loop","begin","ref","of","is","not","put_line","put","return","and","or",
			"mod","skip_line","function","null","get","true","false","int2char","char2int"
		};

		st = new SymbolTable();

		st.insertReservedWords(palsRes);
	}

   public static void main(String[] args) {
	   alike parser = null;
	   initSymbolTable();
	   
	   try {
		   if(args.length == 0) {
			   parser = new alike(System.in);
		   }
		   else {
			   parser = new alike(new java.io.FileInputStream(args[0]));
		   }
		   //Programa es el símbolo inicial de la gramática
		   parser.Programa();
		   //...
		   System.out.println("***** Análisis terminado con éxito *****");
	   }
	   catch (java.io.FileNotFoundException e) {
		   System.err.println ("Fichero " + args[0] + " no encontrado.");
	   }
	   catch (TokenMgrError e) {
		   System.err.println("LEX_ERROR: " + e.getMessage());
	   }
	   catch (ParseException e) {
            System.err.println("PARSER_ERROR: " + e.getMessage());
        }
		catch (ErrorSemantico e) {
			System.err.println("SEMANTIC_ERROR: " + e.getMessage());
			System.err.println("***** Análisis parado por un error *****");
		}
	   //...
   }
}
PARSER_END(alike)

TOKEN_MGR_DECLS : {
	static void CommonTokenAction(Token token) {
		System.err.println("(" + token.beginLine + ", "
					+ token.beginColumn + "): "+ alikeConstants.tokenImage[token.kind] + " " + token.image);
	}

}

SPECIAL_TOKEN : {
	< tCOMMENT: (<COMMENT>) >
}

TOKEN : {
	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|	< #CHAR: (~["\\"]) >
|	< #STRING: (~["\\","\""]|("\"\""))+ >
|	< #COMMENT: ("--")(~["\n"])*("\n") >
}

TOKEN : {
	< tBOOL: "boolean" >
|	< tCHAR: "character" >
|	< tINT: "integer" >
|	< tARRAY: "array" >
|	< tPROC: "procedure" >
|	< tIF:	"if" >
|	< tTHEN: "then" >
|	< tELSIF: "elsif" >
|	< tELSE: "else" >
|	< tENDIF: "end"(" ")+"if"> 
| 	< tEND: "end" >
|	< tWHILE: "while" >
|	< tLOOP: "loop" >
|	< tENDLOOP: "end loop" >
|	< tBEGIN: "begin" >
|	< tREF: "ref" >
|	< tOF: "of" >
|	< tIS: "is" >
|	< tNOT: "not" >
| 	< tPC: ";" >
|	< tPLINE: "put_line" >
|	< tPUT: "put" >
|	< tRETURN: "return" >
|	< tAP: "(" >
|	< tCP: ")" >
|	< tASIG: ":=" >
|	< tGE: ">=" >
|	< tLE: "<=" >
|	< tNEQ: "/=" >
|	< tEQ: "=" >
|	< tGT: ">" >
|	< tLS: "<" >
|	< tDP: ":" >
|	< tAND: "and" >
|	< tOR: "or" >
|	< tADD: "+" >
|	< tSUB: "-" >
|	< tDIV: "/" >
|	< tMUL: "*" >
|	< tCOMA: "," >
|	< tMOD: "mod" >
|	< tSKIP: "skip_line" >
|	< tFUNC : "function" >
|	< tNULL : "null" >
|	< tGET : "get" >
|	< tTRUE : "true" >
|	< tFALSE : "false" >
|	< tINT2CHAR : "int2char" >
|	< tCHAR2INT : "char2int" >
|	< tCONST_CHAR : ("'")(< CHAR >)("'") >
|	< tCONST_INT : (< DIGIT >)+ >
|	< tCONST_STRING : ("\"")(< STRING >)*("\"") >
| 	< tID: (< LETTER >| "_")+(< DIGIT >| "_" | < LETTER >)* > 
}

SKIP : 
{
	" "
|	"\t"
|	"\n"
|	"\r" 
}





//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void Programa():
{
	Token name;
	Attributes at = new Attributes();

	CodeBlock cprog=new CodeBlock(),cprocfun=new CodeBlock(),cbloque=new CodeBlock();
} 
{
	{
		cprog = new CodeBlock();
	}
	<tPROC>
	name = <tID>
	{
		
		try{
			name.image = name.image.toLowerCase();
			if(!st.isReservedWord(name.image))
			{
				st.insertReservedWord(name.image);

				SymbolProcedure S = new SymbolProcedure(name.image, at.parList);
				st.insertSymbol(S);
			}
			else
			{
				throw new ErrorSemantico("ID no valido. Es una palabra reservada");
			}
		} catch (AlreadyDefinedSymbolException ex)
		{
			throw new ErrorSemantico("Simbolo ya existente");
		}
	}
	(<tAP> parametros_formales(at) <tCP>)?
	<tIS>
	( declaracion_variables() )?
	( (declaracion_procs_funcs(cprocfun))+ )?
	<tBEGIN>
	instrucciones(cbloque)
	<tEND>
	<tPC> 
	{
		//System.err.println("Bloque " + name.image + " terminado \n" + st.toString());
		String etiq = CGUtils.newLabel();
		cprog.addInst(PCodeInstruction.OpCode.ENP, etiq);
		cprog.addBlock(cprocfun);
		cprog.addComment("Comienzo main");
		cprog.addLabel(etiq);
		cprog.addBlock(cbloque);
		cprog.addComment("Fin main");
		cprog.addInst(PCodeInstruction.OpCode.LVP);
	}
}

void declaracion_procedimiento(CodeBlock cBlock):
{
	Token name;
	Attributes att = new Attributes();

	CodeBlock cprog=new CodeBlock(),cprocfun=new CodeBlock(),cbloque=new CodeBlock();
}
{
	name = cabecera_procedimiento(att)
	( declaracion_variables() )?
	( declaracion_procs_funcs(cprocfun) )?
	<tBEGIN>
	instrucciones(cbloque)
	<tEND>
	<tPC> 
	{
		//System.err.println("Bloque " + name.image + " terminado \n" + st.toString());
		st.removeBlock();

		String etiq = CGUtils.newLabel();

		cprog.addBlock(cprocfun);
		cprog.addComment("Comienzo "+name.image);
		cprog.addLabel(etiq);
		cprog.addBlock(cbloque);
		cprog.addComment("Fin "+name.image);
		//cprog.addInst(LVP);

		cBlock.addBlock(cprog);
	}
}

void declaracion_funcion(CodeBlock cBlock):
{
	Attributes atType = new Attributes();
	Attributes atIsArray = new Attributes();
	Attributes atts = new Attributes();
	Token name;

	CodeBlock cprog=new CodeBlock(),cprocfun=new CodeBlock(),cbloque=new CodeBlock();
}
{
	name = cabecera_funcion(atType,atIsArray,atts)
	{
		tipoReturn.add(name);
	}
	( declaracion_variables() )?
	( declaracion_procs_funcs(cprocfun) )?
	<tBEGIN>
	{
		
	}
	instrucciones(cbloque)
	<tEND>
	<tPC>
	{
		//System.err.println("Bloque " + name.image + " terminado \n"+ st.toString());
		st.removeBlock();
		if(atType.type == Symbol.Types.ARRAY)
		{
			throw new ErrorSemantico("No se permiten funciones con retorno de vectores");
		}

		tipoReturn.remove(tipoReturn.size()-1);

		String etiq = CGUtils.newLabel();
		//cprog.addInst(ENP, etiq);
		cprog.addBlock(cprocfun);
		cprog.addComment("Comienzo "+name.image);
		cprog.addLabel(etiq);
		cprog.addBlock(cbloque);
		cprog.addComment("Fin "+name.image);
		//cprog.addInst(LVP);

		cBlock.addBlock(cprog);
	}
}

void declaracion_procs_funcs(CodeBlock cBlock):
{}
{
	declaracion_procedimiento(cBlock)
	| declaracion_funcion(cBlock)
}

void instrucciones(CodeBlock cBlock):
{
	CodeBlock cInst = new CodeBlock();
}
{
	(instruccion(cInst)
	{
		cBlock.addBlock(cInst);
		cInst = new CodeBlock();
	}
	(";"))+
}


void declaracion_variables():
{

}
{
	( declaracion_var() ";")+
}

ArrayList<Symbol> declaracion_var():
{
	Attributes atType = new Attributes();
	Attributes atIsArray = new Attributes();
	ArrayList<Token> tokens;
	ArrayList<Symbol> symbols = new ArrayList<Symbol>();
}
{
		tokens = lista_ids()
		<tDP>
		(	
		<tREF>
			{
				atType.parClass = Symbol.ParameterClass.REF;
			}
		)?
		tipo_variable(atType,atIsArray)
		{	
			if(atType.parClass==Symbol.ParameterClass.NONE)atType.parClass=Symbol.ParameterClass.VAL;
			for(Token t : tokens)
			{
				Symbol S = null;

				
				//System.out.println(atType.type + " " + atIsArray.type);
				if(atType.type == Symbol.Types.BOOL) S = new SymbolBool(t.image, atType.parClass);
				if(atType.type == Symbol.Types.CHAR) S = new SymbolChar(t.image, atType.parClass);
				if(atType.type == Symbol.Types.INT) S = new SymbolInt(t.image, atType.parClass);
				if(atType.type == Symbol.Types.ARRAY) 
				{
					if(atType.inicio>atType.fin)
					{
						throw new ErrorSemantico("Indices en declaración de array incoherentes");
					}

					S = new SymbolArray(t.image, atType.inicio,atType.fin,atIsArray.type,atType.parClass);
				}

				symbols.add(S);
				
				try {
					st.insertSymbol(S);
				} catch (AlreadyDefinedSymbolException e)
				{
					throw new ErrorSemantico("Error semantico. Simbolo ya existente");
				}
			}

			return symbols;
		}
}

Attributes lista_componentes():
{
	Token t;
	Attributes att = new Attributes();
	Attributes at = new Attributes();
	Symbol S = null;
}
{
	(
		t=<tID>
			(<tAP>expresion(at)<tCP>)?
			{
				t.image = t.image.toLowerCase();
				if(!st.isReservedWord(t.image))
				{
					try
					{
						t.image = t.image.toLowerCase();
						S = st.getSymbol(t.image);
						sf.cambiarTipos(at, S);
						sf.asignar_valores(att,at,t.image,S.type, S.parClass, st.level,false);
						//sf.checkPrimarioIds(at);
						at = new Attributes();	
					}
					catch(SymbolNotFoundException ex)
					{
						throw new ErrorSemantico(t.image + " no existe.");
					}
				}
				else
				{
					throw new ErrorSemantico("ID no valido. Es una palabra reservada");
				}
			}
	)
	(
		<tCOMA>
		t=<tID>
			(<tAP>expresion(at)<tCP>)?
			{
				t.image = t.image.toLowerCase();
				if(!st.isReservedWord(t.image))
				{
					try
					{
						t.image = t.image.toLowerCase();
						S = st.getSymbol(t.image);
						sf.cambiarTipos(at, S);
						sf.asignar_valores(att,at,t.image,S.type, S.parClass, st.level,false);
						//sf.checkPrimarioIds(at);
						at = new Attributes();	
					}
					catch(SymbolNotFoundException ex)
					{
						throw new ErrorSemantico(t.image + " no existe.");
					}
				}
				else
				{
					throw new ErrorSemantico("ID no valido. Es una palabra reservada");
				}
			}
	)*
		{
			//System.err.println("Lista de ids ");
			return att;
		}
}

ArrayList<Token> lista_ids():
{
	ArrayList<Token> tokens = new ArrayList<Token>();
	Token t;
}
{
	(
		t=<tID>
			{
				t.image = t.image.toLowerCase();
				if(!st.isReservedWord(t.image))
				{
					tokens.add(t);
				}
				else
				{
					throw new ErrorSemantico("ID no valido. Es una palabra reservada");
				}

			}
	)
	(
		<tCOMA>
		t=<tID>
			{
				t.image = t.image.toLowerCase();
				if(!st.isReservedWord(t.image)) tokens.add(t);
				else throw new ErrorSemantico("ID no valido. Es una palabra reservada");
			}
	)*
		{
			//System.err.println("Lista de ids ");
			return tokens;
		}
}

void lista_ids_o_string_o_inv(Attributes att):
{
	Attributes at = new Attributes();
}
{
	expresion(at)
	{
		att.atts.add(at.clone());
		at = new Attributes();
	}
	(<tCOMA> expresion(at) 
	{
		att.atts.add(at.clone());
		at = new Attributes();
	})*
	{
		att.type = att.atts.get(0).type;
		
	}
}


Token cabecera_procedimiento(Attributes att):
{
	Token name;
}
{
	<tPROC>
	name = <tID>
	{
		try {
			name.image = name.image.toLowerCase();
			Symbol S = new SymbolProcedure(name.image,att.parList);
			st.insertSymbol(S);
			st.insertBlock();
		}catch (AlreadyDefinedSymbolException ex)
		{
			throw new ErrorSemantico("Error semantico. Simbolo ya existente");
		}
	}
	(<tAP> 
	parametros_formales(att)
	<tCP>)?
	<tIS>
	{
		return name;
	}
}

Token cabecera_funcion(Attributes atType,Attributes atIsArray,Attributes atts):
{
	Token name;
	SymbolFunction S = null;
}
{
	<tFUNC>
	name = <tID>
	{
		try{ 
			name.image = name.image.toLowerCase();
			S = new SymbolFunction(name.image,atts.parList,atType.type);
			st.insertSymbol(S);
			st.insertBlock();
		} catch (AlreadyDefinedSymbolException ex)
		{
			throw new ErrorSemantico("Error semantico. Simbolo ya existente");
		}
		
	}
	(<tAP> parametros_formales(atts) <tCP>)?
	<tRETURN>
	tipo_variable_simple(atType)
	<tIS>
	{
		S.returnType = atType.type;
		return name;
	}
}

void parametros_formales(Attributes att): 
{
	ArrayList<Symbol> symbols;
}
{
	symbols = declaracion_var()
	{
		// try {
			for(Symbol S : symbols)
			{
				att.parList.add(S);
		// 		st.insertSymbol(S);
			}
		// } catch (AlreadyDefinedSymbolException ex)
		// {
		// 	System.err.println("Error semantico. Simbolo ya existente");
		// }
	}
	(<tPC> 
	symbols = declaracion_var()
	{
		for(Symbol S : symbols)
		{
			att.parList.add(S);
			// st.insertSymbol(S);
		}
	}
	)*
}


void instruccion(CodeBlock cBlock) :
{
	Attributes att = new Attributes();	
	CodeBlock cInst = new CodeBlock();
}
{
	(	inst_leer(att,cInst)
	|   inst_saltar_linea(att,cInst)
	|	inst_escribir(att,cInst)
	|   inst_escribir_linea(att,cInst)
	|   inst_invocacion_o_asignacion(att,cInst)
	|   inst_if(att,cInst)
	|   inst_while(att,cInst)
	|   inst_return(att,cInst)
	|   inst_null(att,cInst)
	)
	{
		cBlock.addBlock(cInst);
	}
}

void inst_leer(Attributes att,CodeBlock cBlock):
{

}
{
	<tGET> 
	<tAP> att = lista_componentes() <tCP>
	{
		sf.check_inst_leer(st,att);
		//System.err.println("Expresion: " + att);
	}
}

void inst_saltar_linea(Attributes att,CodeBlock cBlock):
{}{<tSKIP>}

void inst_escribir(Attributes att,CodeBlock cBlock):
{}
{
	<tPUT> <tAP> lista_ids_o_string_o_inv(att)  <tCP>
	{
		sf.check_inst_escribir(st,att);
		//System.err.println("Expresion: " + att);
	}
}

void inst_escribir_linea(Attributes att,CodeBlock cBlock):
{}
{
	<tPLINE> ((<tAP> lista_ids_o_string_o_inv(att) <tCP>))?
	{
		if(att.atts.size()>0)
		{
			sf.check_inst_escribir(st,att);
		}
	}
}

void inst_invocacion_o_asignacion(Attributes att,CodeBlock cBlock):
{
	Attributes at = new Attributes();
	Attributes at2 = new Attributes();
	Token t;
}
{
	t = <tID>
	(<tAP> ((function_call(at2)))
	<tCP>)? 
	{
		try {
			t.image = t.image.toLowerCase();
			Symbol S = st.getSymbol(t.image);
			//System.err.println("Tipo de la funcion: " + at2);	
			sf.cambiarTipos(at2, S);
			//System.err.println("Tipo de la funcion: " + at2);	
			sf.asignar_valores(att,at2,t.image,S.type, S.parClass, st.level,false);
			if(at2.type==Symbol.Types.ARRAY)
			{
				throw new ErrorSemantico("No se puede realizar una asignación a un array entero");
			}
			sf.checkTypeFunctionCall(at2);
		} catch (SymbolNotFoundException ex)
		{
			throw new ErrorSemantico(t.image + " no existe.");
		}
	} 	
	(<tASIG> expresion(at) 
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		//System.err.println("Expresion en inst: " + att);
		sf.checkTypesAsignacion(at,at2);
		at = new Attributes();
		at2 = new Attributes();
	}
	)?
	{
		//System.err.println("Expresion/es de inv o asignacion: " + att);
	}
}


// void inv_funcion(Attributes att):
// {
// 	Attributes at = new Attributes();
// }
// {
// 	(expresion(at) 
// 	{
// 		att.atts.add(at.clone());
// 	}
// 	(<tCOMA> expresion(at)
// 	{
// 		att.atts.add(at.clone());
// 	}
// 	)*)
// 	{System.err.println("Expresion/es de inv a funcion: " + att);}
// }

void inst_if(Attributes att,CodeBlock cBlock):
{
	Attributes at = new Attributes();
	CodeBlock cbloque=new CodeBlock();
}
{
	<tIF> expresion(at)
	{
		//System.err.println("Expresion if tipo: " + at.type);
		if(at.type==Symbol.Types.ARRAY)
		{
			Attributes aux = at.atts.get(0);
			for(int i=0; i<6 && aux.atts.size()>0; i++)
			{
				aux = aux.atts.get(0);	
				//System.err.println(aux.type);
			}
			if(aux.type!=Symbol.Types.INT)
			{
				throw new ErrorSemantico("No puedes comparar un array entero con un booleano");
			}
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("El array tienen que devolver un booleano: "+at.type);
			}
		} 
		else if(at.type== Symbol.Types.FUNCTION)
		{
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("La funcion tienen que devolver un booleano: "+at.type);
			}
		}
		else if(at.type!=Symbol.Types.BOOL)
		{
			throw new ErrorSemantico("Solo se admiten expresiones booleanas: "+at.type);
		}
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
	}
	<tTHEN> instrucciones(cbloque) ((<tELSIF> expresion(at)
	{
		if(at.type==Symbol.Types.ARRAY)
		{
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("El array tienen que devolver un booleano: "+at.type);
			}
		} 
		else if(at.type== Symbol.Types.FUNCTION)
		{
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("La funcion tienen que devolver un booleano: "+at.type);
			}
		}
		else if(at.type!=Symbol.Types.BOOL)
		{
			throw new ErrorSemantico("Solo se admiten expresiones booleanas: "+at.type);
		}
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();

		// if(at.type!=Symbol.Types.BOOL)
		// {
		// 	throw new ErrorSemantico("Solo se admiten expresiones booleanas: "+at.type);
		// }
	}
	<tTHEN> instrucciones(cbloque))* (<tELSE> instrucciones(cbloque))?) <tENDIF>
	{
		
		//System.err.println("Expresion/es de ifs condiciones: " + att);
	}
} 

void inst_while(Attributes att,CodeBlock cBlock):
{
	Attributes at = new Attributes();

	CodeBlock cbloque=new CodeBlock();
}
{
	<tWHILE> expresion(at)
	{
		if(at.type==Symbol.Types.ARRAY || at.type==Symbol.Types.FUNCTION)
		{
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("Solo se admiten expresiones booleanas: "+at.type);
			}
		}
		else if(at.type!=Symbol.Types.BOOL)
		{
			throw new ErrorSemantico("Solo se admiten expresiones booleanas: "+at.type);
		}
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
	}
	<tLOOP> instrucciones(cbloque) <tENDLOOP>
	{
		//System.err.println("Expresion while condicion: " + att);
	}
}

void inst_return(Attributes att,CodeBlock cBlock):{
	Attributes at = new Attributes();
}
{
	<tRETURN> expresion(at)
	{
		try{
			Symbol S = st.getSymbol(tipoReturn.get(tipoReturn.size()-1).image);
			sf.add_to_atts(att,at);
			
			if(S.type != Symbol.Types.FUNCTION){
				throw new ErrorSemantico("Solo se puede hacer return en funciones");
			} 
			if(at.type == Symbol.Types.FUNCTION)
			{
				if(at.extraType!=((SymbolFunction)S).returnType)
				{
					throw new ErrorSemantico("Error de tipos en return");
				}
			} 
			else if(at.type != ((SymbolFunction)S).returnType)
			{

				throw new ErrorSemantico("Error de tipos en return");
			}
			
			at = new Attributes();
		} catch(SymbolNotFoundException ex) {
			throw new ErrorSemantico("Error semantico. Funcion no encontrada");
		}
	}
}

void inst_null(Attributes att,CodeBlock cBlock):{}{<tNULL>	}


void expresion(Attributes att):
{
	Boolean esBool = false; 
	Attributes at = new Attributes();
}
{
    relacion(at)
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
	}
	( ((<tAND>) 
	{
		att.type = Symbol.Types.BOOL;
		esBool = true;
	}
	relacion(at) 
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
	}
	)+
	|
	((<tOR>) 
	{
		att.type = Symbol.Types.BOOL;
		esBool = true;
	}
	relacion(at) 
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
	}
	)+ )?
	{
		// ( 2+3+4) + 5 + (2+3)
		// Expresion
		//  (2+3+4)
		//   5
		//  (2+3)
		if(esBool)
		{
			 for(Attributes a : att.atts)
			 {
				//System.err.println(a.type);
				if(a.type == Symbol.Types.FUNCTION || a.type == Symbol.Types.ARRAY){
					if(a.extraType!=Symbol.Types.BOOL)
					{
						throw new ErrorSemantico("Error de tipos");
					}
					if(a.type == Symbol.Types.ARRAY){
						Attributes aux = a.atts.get(0);
						for(int i=0; i<5 && aux.atts.size()>0; i++)
						{
							aux = aux.atts.get(0);	
							//System.err.println(aux.type);
						}
						if(aux.type!=Symbol.Types.INT)
						{
							throw new ErrorSemantico("No puedes comparar un array entero con un booleano");
						}
					}
				} else{
					if(a.type!=Symbol.Types.BOOL)
					{
						throw new ErrorSemantico("Error de tipos");
					}
				}
			 }
			 //System.out.println();
		}
		
	}
}

void relacion(Attributes att):
{
	//Attributes atTypes = new Attributes();
	Boolean tieneOpInts = null;
	Attributes at = new Attributes();
}
{
    expresion_simple(at)
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
	}
 	( tieneOpInts = operador_relacional()
	expresion_simple(at)
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		
	} 
	)? 
	{
		if(tieneOpInts!=null)
		{
			att.type = Symbol.Types.BOOL;
			if(tieneOpInts)
			{
				//System.err.println("Operador relacional: " + att);
				for(Attributes a : att.atts)
			 	{
					if (a.type==Symbol.Types.ARRAY || a.type==Symbol.Types.FUNCTION)
					{
						if(a.extraType!=Symbol.Types.INT)
						{
							throw new ErrorSemantico("Error de tipos. Se esperaban integers en relacion: "+a.type);
						}
					} else if(a.type!=Symbol.Types.INT)
			 		{
			 			throw new ErrorSemantico("Error de tipos. Se esperaban integers en relacion: "+a.type);
			 		}
			 	}
			} else {
				if(at.type != Symbol.Types.UNDEFINED) 
				{
					Attributes a2 = att.atts.get(att.atts.size()-2);
					if(a2.type == Symbol.Types.FUNCTION || a2.type == Symbol.Types.ARRAY)
					{
						if(a2.extraType!=at.type)
						{
							throw new ErrorSemantico("Error de tipos. Se esperaban el mismo tipo en relacion: " + a2.extraType + " y "+ at.type);
						}
					} else if(at.type == Symbol.Types.FUNCTION || at.type == Symbol.Types.ARRAY)
					{
						if(a2.type!=at.extraType)
						{
							throw new ErrorSemantico("Error de tipos. Se esperaban el mismo tipo en relacion: " + a2.type + " y "+ at.extraType);
						}
					}
					else if(a2.type!=at.type)
					{
						throw new ErrorSemantico("Error de tipos. Se esperaban el mismo tipo en relacion: " + a2.type + " y "+ at.type);
					}
				}
			}
		}
	}
}

Boolean operador_relacional():
{
	
}
{    
	<tEQ>    {return false;}// Char,bool,int
	| <tLS>  {return true;}// Int
	| <tGT>  {return true;}// Int
	| <tLE>  {return true;}// Int
	| <tGE>  {return true;}// Int
	| <tNEQ> {return false;}// Char,bool,int
}

void expresion_simple(Attributes att):
{
	boolean esInt=false;
	Attributes at = new Attributes();
}
{
	(( <tADD> |	<tSUB> )
	{
		esInt=true;att.type=Symbol.Types.INT;
	})? 
    termino(at)
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at); 
		at = new Attributes();
	}
	( ( <tADD> | <tSUB> ) 
	termino(at) 
	{	
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
		att.type = Symbol.Types.INT;
		//System.err.println("Expresion simple: " + att);
		for(Attributes a : att.atts)
		{
			if(a.type == Symbol.Types.FUNCTION || a.type == Symbol.Types.ARRAY)
			{
				if(a.extraType!=Symbol.Types.INT)
				{
					throw new ErrorSemantico("Error de tipos. Se esperaban integers en expresion simple: " + a.type);
				}
			} else if(a.type!=Symbol.Types.INT)
			{
				throw new ErrorSemantico("Error de tipos. Se esperaban integers en expresion simple: " + a.type);
			}
		}
	})*
}

void termino(Attributes att):
{
	Attributes at = new Attributes();
}
{
    factor(at) 
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
	}
	( operador_multiplicativo() factor(at)
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		att.type = Symbol.Types.INT;
		at = new Attributes();
		
		for(Attributes a : att.atts)
		{
			if(a.type == Symbol.Types.FUNCTION || a.type == Symbol.Types.ARRAY)
			{
				if(a.extraType!=Symbol.Types.INT)
				{
					throw new ErrorSemantico("Error de tipos. Se esperaban integers en termino: " + att.atts.get(0).type);
				}
			} else if(a.type!=Symbol.Types.INT)
			{
				throw new ErrorSemantico("Error de tipos. Se esperaban integers en termino: " + att.atts.get(0).type);
			}
		}
	}
	
	)*
}

void operador_multiplicativo():
{}
{
    <tMUL> | <tMOD> | <tDIV>
}

void factor(Attributes att):
{
	Attributes at = new Attributes();
}
{
    primario(at) 
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
		
	}

|   <tNOT>  primario(at)
	{
		att.type = Symbol.Types.BOOL;
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		if(at.type == Symbol.Types.ARRAY)
		{
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("El array tienen que devolver un booleano: "+at.type);
			}
		} 
		else if(at.type == Symbol.Types.FUNCTION)
		{
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("La funcion tienen que devolver un booleano: "+at.type);
			}
		}
		else if(at.type!=Symbol.Types.BOOL)
		{
			throw new ErrorSemantico("Solo se admiten expresiones booleanas: "+at.type);
		}
		at = new Attributes();
	}
}

void primario(Attributes att) :
{ 
	Attributes at = new Attributes();

	Token t;
	Symbol S;
}
{
	<tAP> expresion(at) <tCP> 
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
	}
|   <tINT2CHAR> <tAP> expresion(at) <tCP> 
	{
		if(at.type!=Symbol.Types.INT)
		{
			throw new ErrorSemantico("int2char solo acepta enteros");
		}
		if(at.atts.size()!=1){
			throw new ErrorSemantico("int2char solo acepta un entero");
		}
		sf.asignar_valores(att,at,"int2char(" + at.code + ")",Symbol.Types.CHAR, Symbol.ParameterClass.VAL, st.level, true);
		sf.heredar_valores(att,at);
	}
|   <tCHAR2INT> <tAP> expresion(at) <tCP> 
	{
		if(at.type!=Symbol.Types.CHAR)
		{
			throw new ErrorSemantico("char2int solo acepta caracteres");
		}
		if(at.atts.size()!=1){
			throw new ErrorSemantico("char2int solo acepta un caracter");
		}
		sf.asignar_valores(att,at,"char2int(" + at.code + ")",Symbol.Types.INT, Symbol.ParameterClass.VAL, st.level,true);
		sf.heredar_valores(att,at);
	}
|   t=<tID> (<tAP> (function_call(at)) <tCP> )?  
	{
		try
		{
			t.image = t.image.toLowerCase();
			S = st.getSymbol(t.image);
			sf.cambiarTipos(at, S);
			sf.asignar_valores(att,at,t.image,S.type, S.parClass, st.level,false);
			sf.checkPrimarioIds(at);
			at = new Attributes();			
		}
		catch(SymbolNotFoundException ex)
		{
			throw new ErrorSemantico(t.image + " no existe.");
		}

	}
|   ("-")? t= <tCONST_INT> 
    {
		sf.asignar_valores(att,at,t.image,Symbol.Types.INT, Symbol.ParameterClass.VAL, st.level,true);
	}
|   t= <tCONST_CHAR> 
	{
		sf.asignar_valores(att,at,t.image,Symbol.Types.CHAR, Symbol.ParameterClass.VAL, st.level,true);
	}
|   t= <tCONST_STRING> 
	{
		sf.asignar_valores(att,at,t.image,Symbol.Types.STRING, Symbol.ParameterClass.VAL, st.level,true);
	}
|   t= <tTRUE>	
	{
		sf.asignar_valores(att,at,"true",Symbol.Types.BOOL, Symbol.ParameterClass.VAL, st.level,true);
	}
|   t= <tFALSE> 
	{
		sf.asignar_valores(att,at,"false",Symbol.Types.BOOL, Symbol.ParameterClass.VAL, st.level,true);
	}
}


void function_call(Attributes att) :
{ 
	Attributes at = new Attributes();
}
{
 ( expresion(at)
 {
	sf.add_to_atts(att,at);
	sf.heredar_valores(att,at);
	at = new Attributes();
 } 
 ((<tCOMA>) expresion(at)
 {
	sf.add_to_atts(att,at);
	sf.heredar_valores(att,at);
	at = new Attributes();
}
)* 
 ) 
 {
	
 }
}


void tipo_variable(Attributes atTypes, Attributes atIsArray):
{ 
	Token i;
}
{
	< tARRAY >
	<tAP>
	("-")? i = < tCONST_INT >
		{
			atTypes.inicio = Integer.parseInt(i.image);
			
			//at.parList.add(new Symbol(i.image,Symbol.Types.INT));
			
		}
	("..")
	("-")? i = < tCONST_INT >
		{
			atTypes.fin = Integer.parseInt(i.image);
			// at.parList.add(new Symbol(i.image,Symbol.Types.INT));
			atTypes.type = Symbol.Types.ARRAY;
		}
	<tCP>
	 <tOF> tipo_variable_simple(atIsArray)
|   tipo_variable_simple(atTypes)
}

void tipo_variable_simple(Attributes at):
{

}
{
		< tBOOL > 
			{
				at.type = Symbol.Types.BOOL;
			}
	|	< tCHAR >
			{
				at.type = Symbol.Types.CHAR;
			}
	|	< tINT >
			{
				at.type = Symbol.Types.INT;
			}
}

