//*****************************************************************
// File:   cl.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
// Date:   julio 2023
// Coms:   compilar mediante "ant"
//*****************************************************************

options {
	IGNORE_CASE = true;
	COMMON_TOKEN_ACTION = true;
}

PARSER_BEGIN(alike)

package traductor;

//...

import lib.symbolTable.*;
import lib.attributes.*;
import lib.symbolTable.exceptions.*;
import java.util.ArrayList;
import java.util.Collections;
import lib.errores.*;
import lib.tools.SemanticFunctions;
import lib.tools.codeGeneration.*;
import static lib.symbolTable.Symbol.Types.*;
import java.io.*;

public class alike { 


	static SymbolTable st;
	static SemanticFunctions sf = new SemanticFunctions();
	static ArrayList<Token> tipoReturn = new ArrayList<Token>();

	static int linea = 0;

	private static void initSymbolTable() {
		boolean b;
		String[] palsRes = {
	    	"array","boolean","character","integer","procedure","if","then","elsif","else","end",
			"while","loop","begin","ref","of","is","not","put_line","put","return","and","or",
			"mod","skip_line","function","null","get","true","false","int2char","char2int"
		};

		st = new SymbolTable();

		st.insertReservedWords(palsRes);
	}

   public static void main(String[] args) {
	   alike parser = null;
	   initSymbolTable();
	   
	   try {
		   if(args.length == 0) {
			   parser = new alike(System.in);
		   }
		   else {
			   parser = new alike(new java.io.FileInputStream(args[0]));
		   }
		   //Programa es el símbolo inicial de la gramática
		   parser.Programa(args[0]);
		   //...
		   System.out.println("***** Análisis terminado con éxito *****");
	   }
	   catch (java.io.FileNotFoundException e) {
		   System.err.println ("Fichero " + args[0] + " no encontrado.");
	   }
	   catch (TokenMgrError e) {
		   System.err.println("LEX_ERROR: " + e.getMessage());
	   }
	   catch (ParseException e) {
            System.err.println("PARSER_ERROR: " + e.getMessage());
        }
		catch (ErrorSemantico e) {
			System.err.println("SEMANTIC_ERROR: " + e.getMessage());
			System.err.println("***** Análisis parado por un error *****");
		}
	   //...
   }
}
PARSER_END(alike)

TOKEN_MGR_DECLS : {
	static void CommonTokenAction(Token token) {
		alike.linea = token.beginLine;
		// System.err.println("(" + token.beginLine + ", "
		// 			+ token.beginColumn + "): "+ alikeConstants.tokenImage[token.kind] + " " + token.image);
	}

}

SPECIAL_TOKEN : {
	< tCOMMENT: (<COMMENT>) >
}

TOKEN : {
	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|	< #CHAR: (~["\\"]) >
|	< #STRING: (~["\\","\""]|("\"\""))+ >
|	< #COMMENT: ("--")(~["\n"])*("\n") >
}

TOKEN : {
	< tBOOL: "boolean" >
|	< tCHAR: "character" >
|	< tINT: "integer" >
|	< tARRAY: "array" >
|	< tPROC: "procedure" >
|	< tIF:	"if" >
|	< tTHEN: "then" >
|	< tELSIF: "elsif" >
|	< tELSE: "else" >
|	< tENDIF: "end"(" ")+"if"> 
| 	< tEND: "end" >
|	< tWHILE: "while" >
|	< tLOOP: "loop" >
|	< tENDLOOP: "end loop" >
|	< tBEGIN: "begin" >
|	< tREF: "ref" >
|	< tOF: "of" >
|	< tIS: "is" >
|	< tNOT: "not" >
| 	< tPC: ";" >
|	< tPLINE: "put_line" >
|	< tPUT: "put" >
|	< tRETURN: "return" >
|	< tAP: "(" >
|	< tCP: ")" >
|	< tASIG: ":=" >
|	< tGE: ">=" >
|	< tLE: "<=" >
|	< tNEQ: "/=" >
|	< tEQ: "=" >
|	< tGT: ">" >
|	< tLS: "<" >
|	< tDP: ":" >
|	< tAND: "and" >
|	< tOR: "or" >
|	< tADD: "+" >
|	< tSUB: "-" >
|	< tDIV: "/" >
|	< tMUL: "*" >
|	< tCOMA: "," >
|	< tMOD: "mod" >
|	< tSKIP: "skip_line" >
|	< tFUNC : "function" >
|	< tNULL : "null" >
|	< tGET : "get" >
|	< tTRUE : "true" >
|	< tFALSE : "false" >
|	< tINT2CHAR : "int2char" >
|	< tCHAR2INT : "char2int" >
|	< tCONST_CHAR : ("'")(< CHAR >)("'") >
|	< tCONST_INT : (< DIGIT >)+ >
|	< tCONST_STRING : ("\"")(< STRING >)*("\"") >
| 	< tID: (< LETTER >| "_")+(< DIGIT >| "_" | < LETTER >)* > 
}

SKIP : 
{
	" "
|	"\t"
|	"\n"
|	"\r" 
}





//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void Programa(String filename):
{
	Token name;
	Attributes at = new Attributes();

	CodeBlock cprog=new CodeBlock(), cprocvar=new CodeBlock(),cprocfun=new CodeBlock(),cbloque=new CodeBlock();
} 
{
	{
		cprog = new CodeBlock();
		String etiq = CGUtils.newLabel();
		CGUtils.initializeCGUtils();
	}
	<tPROC>
	name = <tID>
	{
		
		try{
			name.image = name.image.toLowerCase();
			if(!st.isReservedWord(name.image))
			{
				st.insertReservedWord(name.image);

				SymbolProcedure S = new SymbolProcedure(name.image, at.parList);
				st.insertSymbol(S);
			}
			else
			{
				throw new ErrorSemantico("ID no valido. Es una palabra reservada");
			}
		} catch (AlreadyDefinedSymbolException ex)
		{
			throw new ErrorSemantico("Simbolo ya existente");
		}
	}
	<tIS>
	( declaracion_variables(cprocvar, false) )?
	( (declaracion_procs_funcs(cprocfun))+ )?
	<tBEGIN>
	instrucciones(cbloque)
	<tEND>
	<tPC> 
	{
		//System.err.println("Bloque " + name.image + " terminado \n" + st.toString());
		cprog.addInst(PCodeInstruction.OpCode.ENP, etiq);
		cprog.addBlock(cprocvar);
		cprog.addBlock(cprocfun);
		cprog.addComment("Comienzo main");
		cprog.addLabel(etiq);
		cprog.addBlock(cbloque);
		cprog.addComment("Fin main");
		cprog.addInst(PCodeInstruction.OpCode.LVP);
		//System.out.println(cprog.toString());

		File f = new File(filename);

		String fName = f.getName();
		int pos = fName.lastIndexOf(".");
		if (pos > 0) {
			fName = fName.substring(0, pos);
		}

		f = new File(fName+".pcode");

		try{
			BufferedWriter writer = new BufferedWriter(new FileWriter(f));
			writer.write(cprog.toString());
			writer.close();
		} catch(IOException ex)
		{
			System.err.println("Error en la escritura a fichero");
		}
	}
}

void declaracion_procedimiento(CodeBlock cBlock):
{
	Token name;
	Attributes att = new Attributes();

	CodeBlock cprog=new CodeBlock(),cparam = new CodeBlock(),cprocfun=new CodeBlock(),cprocvar=new CodeBlock(),cbloque=new CodeBlock();
	CGUtils.addLevel();
	String etiq = CGUtils.newLabel();
}
{
	name = cabecera_procedimiento(att, cparam)
	( declaracion_variables(cprocvar, false) )?
	( declaracion_procs_funcs(cprocfun) )?
	{
		try{
		SymbolProcedure S = (SymbolProcedure) st.getSymbol(name.image);
		S.etiq = etiq;
		}catch(SymbolNotFoundException ex)
		{
			throw new ErrorSemantico(name.image + " no existe.");
		}

		
	}
	<tBEGIN>
	instrucciones(cbloque)
	<tEND>
	<tPC> 
	{
		//System.err.println("Bloque " + name.image + " terminado \n" + st.toString());
		st.removeBlock();
		CGUtils.removeLevel();

		cprog.addComment("Comienzo procedure "+name.image);
		cprog.addLabel(etiq);
		cprog.addBlock(cparam);

		String labelCode = CGUtils.newLabel();
		cprog.addInst(PCodeInstruction.OpCode.JMP,labelCode);

		cprog.addBlock(cprocvar);
		cprog.addBlock(cprocfun);
		
		cprog.addLabel(labelCode);
		cprog.addBlock(cbloque);
		cprog.addComment("Fin procedure "+name.image);
		cprog.addInst(PCodeInstruction.OpCode.CSF);
		cBlock.addBlock(cprog);
	}
}

void declaracion_funcion(CodeBlock cBlock):
{
	Attributes atType = new Attributes();
	Attributes atIsArray = new Attributes();
	Attributes atts = new Attributes();
	Token name;
	String etiq = CGUtils.newLabel();
	CodeBlock cprog=new CodeBlock(),cparam = new CodeBlock(), cprocvar=new CodeBlock(),cprocfun=new CodeBlock(),cbloque=new CodeBlock();
	CGUtils.addLevel();
}
{
	name = cabecera_funcion(atType,atIsArray,atts, cparam)
	{
		tipoReturn.add(name);
	}
	( declaracion_variables(cprocvar, false) )?
	( declaracion_procs_funcs(cprocfun) )?
	<tBEGIN>
	{
		try{
		SymbolFunction S = (SymbolFunction) st.getSymbol(name.image);
		S.etiq = etiq;
		}catch(SymbolNotFoundException ex)
		{
			throw new ErrorSemantico(name.image + " no existe.");
		}

		

	}
	instrucciones(cbloque)
	<tEND>
	<tPC>
	{
		//System.err.println("Bloque " + name.image + " terminado \n"+ st.toString());
		st.removeBlock();
		CGUtils.removeLevel();

		if(atType.type == Symbol.Types.ARRAY)
		{
			throw new ErrorSemantico("No se permiten funciones con retorno de vectores");
		}

		tipoReturn.remove(tipoReturn.size()-1);

		cprog.addComment("Comienzo function "+name.image);
		cprog.addLabel(etiq);
		cprog.addBlock(cparam);

		String labelCode = CGUtils.newLabel();
		cprog.addInst(PCodeInstruction.OpCode.JMP,labelCode);

		cprog.addBlock(cprocvar);
		cprog.addBlock(cprocfun);

		cprog.addLabel(labelCode);

		cprog.addBlock(cbloque);
		cprog.addComment("Fin function "+name.image);
		cprog.addInst(PCodeInstruction.OpCode.CSF);
		cBlock.addBlock(cprog);
	}
}

void declaracion_procs_funcs(CodeBlock cBlock):
{}
{
	declaracion_procedimiento(cBlock)
	| declaracion_funcion(cBlock)
}

void instrucciones(CodeBlock cBlock):
{
	CodeBlock cInst = new CodeBlock();
}
{
	(instruccion(cInst)
	{
		cBlock.addBlock(cInst);
		cInst = new CodeBlock();
	}
	(";"))+
}


void declaracion_variables(CodeBlock cprocvar, Boolean esParametro):
{

}
{
	( declaracion_var(cprocvar, esParametro) ";")+
}

ArrayList<Symbol> declaracion_var(CodeBlock cprocvar, Boolean esParametro):
{
	Attributes atType = new Attributes();
	Attributes atIsArray = new Attributes();
	ArrayList<Token> tokens;
	ArrayList<Symbol> symbols = new ArrayList<Symbol>();
}
{
		tokens = lista_ids()
		<tDP>
		(	
		<tREF>
			{
				atType.parClass = Symbol.ParameterClass.REF;
			}
		)?
		tipo_variable(atType,atIsArray)
		{	
			if(atType.parClass==Symbol.ParameterClass.NONE)atType.parClass=Symbol.ParameterClass.VAL;
			for(Token t : tokens)
			{
				Symbol S = null;

				
				//System.out.println(atType.type + " " + atIsArray.type);
				if(atType.type == Symbol.Types.BOOL) S = new SymbolBool(t.image, atType.parClass);
				if(atType.type == Symbol.Types.CHAR) S = new SymbolChar(t.image, atType.parClass);
				if(atType.type == Symbol.Types.INT) S = new SymbolInt(t.image, atType.parClass);
				if(atType.type == Symbol.Types.ARRAY) 
				{
					if(atType.inicio>atType.fin)
					{
						throw new ErrorSemantico("Indices en declaración de array incoherentes");
					}

					S = new SymbolArray(t.image, atType.inicio,atType.fin,atIsArray.type,atType.parClass);
				}
				symbols.add(S);

				
				try {
					
					String name = "";
					Symbol.Types type = Symbol.Types.UNDEFINED;
					long inicio=0, fin = 0;
					if(S.type == Symbol.Types.ARRAY) {
						inicio = CGUtils.getDir();
						S.dir = inicio;
						if(S.parClass != Symbol.ParameterClass.REF){
							for (int i = atType.inicio+1; i < atType.fin; i++) {
								fin = CGUtils.getDir();
							}
							fin = CGUtils.getDir();
						}
						name = "Array";
						SymbolArray symbolArrayInstance = (SymbolArray) S;
						type = symbolArrayInstance.baseType;
						if(!esParametro) cprocvar.addComment("- " + name + " variable \"" + t.image + "\", type " + type + ", size " + ( symbolArrayInstance.maxInd-symbolArrayInstance.minInd+1) +", level " + st.level + ", address [" + inicio + ":" + fin + "]!");
						else {
							if(S.parClass == Symbol.ParameterClass.REF) cprocvar.addComment("- " + name +" parameter \"" + t.image + "\", type " + type + ", size " + ( symbolArrayInstance.maxInd-symbolArrayInstance.minInd+1) + ", class " + S.parClass + ", level " + st.level + ", address ["+S.dir+"]!");
							else
							cprocvar.addComment("- " + name +" parameter \"" + t.image + "\", type " + type + ", size " + ( symbolArrayInstance.maxInd-symbolArrayInstance.minInd+1) + ", class " + S.parClass + ", level " + st.level + ", address [" + inicio + ":" + fin + "]!");
						}
					} else {
					S.dir = CGUtils.getDir();
					if(!esParametro && S.type != Symbol.Types.ARRAY) {type = S.type; cprocvar.addComment("- Simple variable \"" + t.image + "\", type " + type + ", level " + st.level + ", address [" + S.dir + "]!");}
					else {type = S.type;cprocvar.addComment("- Simple parameter \"" + t.image + "\", type " + type + ", class " + S.parClass + ", level " + st.level + ", address [" + S.dir + "]!");}
					}
					st.insertSymbol(S);
				} catch (AlreadyDefinedSymbolException e)
				{
					throw new ErrorSemantico("Error semantico. Simbolo ya existente");
				}
			}

			return symbols;
		}
}

Attributes lista_componentes():
{
	Token t;
	Attributes att = new Attributes();
	Attributes at = new Attributes();
	Symbol S = null;
	CodeBlock cBlock = new CodeBlock();
}
{
	(
		t=<tID>
			(<tAP>expresion(at, cBlock)<tCP>)?
			{
				t.image = t.image.toLowerCase();
				if(!st.isReservedWord(t.image))
				{
					try
					{
						t.image = t.image.toLowerCase();
						S = st.getSymbol(t.image);
						sf.cambiarTipos(at, S);
						sf.asignar_valores(att,at,t.image,S.type, S.parClass, st.level,false);
						//sf.checkPrimarioIds(at);
						at = new Attributes();	
					}
					catch(SymbolNotFoundException ex)
					{
						throw new ErrorSemantico(t.image + " no existe.");
					}
				}
				else
				{
					throw new ErrorSemantico("ID no valido. Es una palabra reservada");
				}
			}
	)
	(
		<tCOMA>
		t=<tID>
			(<tAP>expresion(at, cBlock)<tCP>)?
			{
				t.image = t.image.toLowerCase();
				if(!st.isReservedWord(t.image))
				{
					try
					{
						t.image = t.image.toLowerCase();
						S = st.getSymbol(t.image);
						sf.cambiarTipos(at, S);
						sf.asignar_valores(att,at,t.image,S.type, S.parClass, st.level,false);
						//sf.checkPrimarioIds(at);
						at = new Attributes();	
					}
					catch(SymbolNotFoundException ex)
					{
						throw new ErrorSemantico(t.image + " no existe.");
					}
				}
				else
				{
					throw new ErrorSemantico("ID no valido. Es una palabra reservada");
				}
			}
	)*
		{
			//System.err.println("Lista de ids ");
			return att;
		}
}

ArrayList<Token> lista_ids():
{
	ArrayList<Token> tokens = new ArrayList<Token>();
	Token t;
}
{
	(
		t=<tID>
			{
				t.image = t.image.toLowerCase();
				if(!st.isReservedWord(t.image))
				{
					tokens.add(t);
				}
				else
				{
					throw new ErrorSemantico("ID no valido. Es una palabra reservada");
				}

			}
	)
	(
		<tCOMA>
		t=<tID>
			{
				t.image = t.image.toLowerCase();
				if(!st.isReservedWord(t.image)) tokens.add(t);
				else throw new ErrorSemantico("ID no valido. Es una palabra reservada");
			}
	)*
		{
			//System.err.println("Lista de ids ");
			return tokens;
		}
}

void lista_ids_o_string_o_inv(Attributes att, CodeBlock cBlock):
{
	Attributes at = new Attributes();
}
{
	expresion(at, cBlock)
	{
		att.atts.add(at.clone());
		switch (at.type){
			case STRING:
				String code = at.code;
				if (code.startsWith("\"") && code.endsWith("\"")) {
					code = code.substring(1, code.length() - 1);
				}
				if (code.contains("\"\"")) {
					code = code.replace("\"\"", "\"");
				}
				cBlock.addComment("- Write STRING \"" + code + "\".");
				for(char c: code.toCharArray()) {
					cBlock.addComment("- Write CHAR \"" + c + "\".");
					cBlock.addInst(PCodeInstruction.OpCode.STC, (int)c);
					cBlock.addInst(PCodeInstruction.OpCode.WRT, 0);
				}
				break;
			case CHAR:
				cBlock.addComment("- Write CHAR \"" + at.code + "\".");

				if(!at.code.contains("int2char"))
				{
					//cBlock.addInst(PCodeInstruction.OpCode.STC, (int)at.code.charAt(0));
					cBlock.addInst(PCodeInstruction.OpCode.WRT, 0);
				} else {
					cBlock.addInst(PCodeInstruction.OpCode.WRT, 0);
				}
				break;
				
		}

		at = new Attributes();
	}
	(<tCOMA> expresion(at, cBlock) 
	{
		att.atts.add(at.clone());
		switch (at.type){
			case STRING:
				String code = at.code;
				if (code.startsWith("\"") && code.endsWith("\"")) {
					code = code.substring(1, code.length() - 1);
				}
				if (code.contains("\"\"")) {
					code = code.replace("\"\"", "\"");
				}
				cBlock.addComment("- Write STRING \"" + code + "\".");
				for(char c: code.toCharArray()) {
					cBlock.addComment("- Write CHAR \"" + c + "\".");
					cBlock.addInst(PCodeInstruction.OpCode.STC, (int)c);
					cBlock.addInst(PCodeInstruction.OpCode.WRT, 0);
				}
				break;
			case CHAR:
				if(!at.code.contains("int2char"))
				{
					cBlock.addComment("- Write CHAR \"" + at.code + "\".");
					//cBlock.addInst(PCodeInstruction.OpCode.STC, (int)at.code.charAt(0));
					cBlock.addInst(PCodeInstruction.OpCode.WRT, 0);
				} else {
					cBlock.addComment("- Write CHAR \"" + at.code + "\".");
				}
				
				break;
				
		}

		at = new Attributes();

	})*
	{
		att.type = att.atts.get(0).type;
		
	}
}


Token cabecera_procedimiento(Attributes att, CodeBlock cprog):
{
	Token name;
	String lbel = CGUtils.newLabel();
}
{
	<tPROC>
	name = <tID>
	{
		try {
			name.image = name.image.toLowerCase();
			Symbol S = new SymbolProcedure(name.image,att.parList);
			st.insertSymbol(S);
			st.insertBlock();
		}catch (AlreadyDefinedSymbolException ex)
		{
			throw new ErrorSemantico("Error semantico. Simbolo ya existente");
		}
	}
	(<tAP> 
	parametros_formales(att, cprog)
	<tCP>)?
	<tIS>
	{
		return name;
	}
}

Token cabecera_funcion(Attributes atType,Attributes atIsArray,Attributes atts, CodeBlock cprog):
{
	Token name;
	SymbolFunction S = null;
}
{
	<tFUNC>
	name = <tID>
	{
		try{ 
			name.image = name.image.toLowerCase();
			S = new SymbolFunction(name.image,atts.parList,atType.type);
			st.insertSymbol(S);
			st.insertBlock();
		} catch (AlreadyDefinedSymbolException ex)
		{
			throw new ErrorSemantico("Error semantico. Simbolo ya existente");
		}
		
	}
	(<tAP> parametros_formales(atts, cprog) <tCP>)?
	<tRETURN>
	tipo_variable_simple(atType)
	<tIS>
	{
		S.returnType = atType.type;
		return name;
	}
}

void parametros_formales(Attributes att, CodeBlock cprog): 
{
	ArrayList<Symbol> symbols;
	CodeBlock cprocvar = new CodeBlock();
	CodeBlock auxBlock = new CodeBlock();
	CodeBlock auxBlock1 = new CodeBlock();
	CodeBlock auxBlock2 = new CodeBlock();
	boolean rightSweepingSide = true;
}
{
	symbols = declaracion_var(cprocvar, true)
	{
		// try {
			
			cprog.addBlock(cprocvar);
			cprocvar = new CodeBlock();

			for (int j = symbols.size() - 1; j >= 0; j--) {
				// whatever
				Symbol S = symbols.get(j);

				att.parList.add(S);

				if(S instanceof SymbolArray && S.parClass!=Symbol.ParameterClass.REF)
				{
					SymbolArray SA = (SymbolArray) S;

					for(int i = SA.maxInd-SA.minInd+1;i>0;i--)
					{
						auxBlock1.addInst(PCodeInstruction.OpCode.SRF,(st.level - S.nivel),(int)S.dir+i);
						auxBlock1.addInst(PCodeInstruction.OpCode.ASGI);
					}
				}
				else
				{
					auxBlock1.addInst(PCodeInstruction.OpCode.SRF,(st.level - S.nivel),(int)S.dir);
					auxBlock1.addInst(PCodeInstruction.OpCode.ASGI);
				}
			}

			auxBlock = auxBlock1;

			
		// } catch (AlreadyDefinedSymbolException ex)
		// {
		// 	System.err.println("Error semantico. Simbolo ya existente");
		// }
	}
	(<tPC> 
	symbols = declaracion_var(cprocvar, true)
	{
		cprog.addBlock(cprocvar);
		cprocvar = new CodeBlock();

		for (int j = symbols.size() - 1; j >= 0; j--) {
			// whatever
			Symbol S = symbols.get(j);

			att.parList.add(S);

			if(S instanceof SymbolArray && S.parClass!=Symbol.ParameterClass.REF)
			{
				SymbolArray SA = (SymbolArray) S;

				for(int i = SA.maxInd-SA.minInd+1;i>0;i--)
				{
					if(rightSweepingSide)
					{
						auxBlock2.addInst(PCodeInstruction.OpCode.SRF,(st.level - S.nivel),(int)S.dir+i);
						auxBlock2.addInst(PCodeInstruction.OpCode.ASGI);
					}
					else
					{
						auxBlock1.addInst(PCodeInstruction.OpCode.SRF,(st.level - S.nivel),(int)S.dir+i);
						auxBlock1.addInst(PCodeInstruction.OpCode.ASGI);
					}
				}
			}
			else
			{
				if(rightSweepingSide)
				{
					auxBlock2.addInst(PCodeInstruction.OpCode.SRF,(st.level - S.nivel),(int)S.dir);
					auxBlock2.addInst(PCodeInstruction.OpCode.ASGI);
				}
				else
				{
					auxBlock1.addInst(PCodeInstruction.OpCode.SRF,(st.level - S.nivel),(int)S.dir);
					auxBlock1.addInst(PCodeInstruction.OpCode.ASGI);
				}
			}
		}

		if(rightSweepingSide)
		{
			auxBlock2.addBlock(auxBlock1);
			auxBlock = auxBlock2;
		}
		else
		{
			auxBlock1.addBlock(auxBlock2);
			auxBlock = auxBlock1;
		}

		rightSweepingSide = !rightSweepingSide;

		
	}
	)*
	{
		cprog.addBlock(auxBlock);
	}
}


void instruccion(CodeBlock cBlock) :
{
	Attributes att = new Attributes();	
	CodeBlock cInst = new CodeBlock();
}
{
	(	inst_leer(att,cInst)
	|   inst_saltar_linea(att,cInst)
	|	inst_escribir(att,cInst)
	|   inst_escribir_linea(att,cInst)
	|   inst_invocacion_o_asignacion(att,cInst)
	|   inst_if(att,cInst)
	|   inst_while(att,cInst)
	|   inst_return(att,cInst)
	|   inst_null(att,cInst)
	)
	{
		//System.out.println(cInst.toString());
		cBlock.addBlock(cInst);
	}
}

void inst_leer(Attributes att,CodeBlock cBlock):
{

}
{
	<tGET> 
	<tAP> att = lista_componentes() <tCP>
	{
		sf.check_inst_leer(st,att);
	}
	{	
		for (Attributes a : att.atts)
		{	
			try{
				Symbol S = st.getSymbol(a.code);
				cBlock.addComment("- Get simple variable/parameter \"" + a.code + "\".");
				cBlock.addInst(PCodeInstruction.OpCode.SRF, (st.level - S.nivel), (int)S.dir);
				cBlock.addInst(PCodeInstruction.OpCode.RD, a.type== Symbol.Types.INT?1:0);
			} catch (SymbolNotFoundException ex)
			{
				throw new ErrorSemantico(a.code + " no existe.");
			}
		}
	}
}

void inst_saltar_linea(Attributes att,CodeBlock cBlock):
{}{<tSKIP>
	{
		String et = CGUtils.newLabel();
		cBlock.addLabel(et);
		long dir = CGUtils.getDir();
		cBlock.addInst(PCodeInstruction.OpCode.SRF, 0, (int)dir);
		cBlock.addInst(PCodeInstruction.OpCode.RD, 0);
		cBlock.addInst(PCodeInstruction.OpCode.SRF, 0, (int)dir);
		cBlock.addInst(PCodeInstruction.OpCode.DRF);
		cBlock.addInst(PCodeInstruction.OpCode.STC, 10);
		cBlock.addInst(PCodeInstruction.OpCode.EQ);
		cBlock.addInst(PCodeInstruction.OpCode.JMF, et);
	}
}

void inst_escribir(Attributes att,CodeBlock cBlock):
{}
{
	<tPUT> <tAP> lista_ids_o_string_o_inv(att, cBlock)  <tCP>
	{
		sf.check_inst_escribir(st,att);
		//cBlock.addComment("- Write CR/LF");
		/*cBlock.addInst(PCodeInstruction.OpCode.STC, 13);
		cBlock.addInst(PCodeInstruction.OpCode.WRT, 0);
		cBlock.addInst(PCodeInstruction.OpCode.STC, 10);
		cBlock.addInst(PCodeInstruction.OpCode.WRT, 0);*/
		//System.err.println("Expresion: " + att);
	}
}

void inst_escribir_linea(Attributes att,CodeBlock cBlock):
{}
{
	<tPLINE> ((<tAP> lista_ids_o_string_o_inv(att, cBlock) <tCP>))?
	{
		if(att.atts.size()>0)
		{
			sf.check_inst_escribir(st,att);
		}
		cBlock.addComment("- Write CR/LF");
		cBlock.addInst(PCodeInstruction.OpCode.STC, 13);
		cBlock.addInst(PCodeInstruction.OpCode.WRT, 0);
		cBlock.addInst(PCodeInstruction.OpCode.STC, 10);
		cBlock.addInst(PCodeInstruction.OpCode.WRT, 0);
	}
}

void inst_invocacion_o_asignacion(Attributes att,CodeBlock cBlock):
{
	Attributes at = new Attributes();
	Attributes at2 = new Attributes();
	Symbol S = null;
	Token t;
}
{
	t = <tID>
	{
		try {
			t.image = t.image.toLowerCase();
			S = st.getSymbol(t.image);

		} catch (SymbolNotFoundException ex)
		{
			throw new ErrorSemantico(t.image + " no existe.");
		}
	}
	(<tAP> ((function_call(at2,cBlock,S)))
	<tCP>)? 
	{
			//System.err.println("Tipo de la funcion: " + at2);	
			sf.cambiarTipos(at2, S);
			//System.err.println("Tipo de la funcion: " + at2);	
			sf.asignar_valores(att,at2,t.image,S.type, S.parClass, st.level,false);
			if(at2.type==Symbol.Types.ARRAY)
			{
				throw new ErrorSemantico("No se puede realizar una asignación a un array entero");
			}
			sf.checkTypeFunctionCall(at2);

			for(int i = 0; i<at2.atts.size(); i++)
			{
				System.out.println("\t"+at2.atts.get(i).parClass);
			}

			if(S.type == Symbol.Types.PROCEDURE)
			{
				SymbolProcedure SP = (SymbolProcedure) S;
				cBlock.addOSFInst(CGUtils.getInvocDir(),st.level-S.nivel,SP.etiq);
			}

			if(S.type == Symbol.Types.FUNCTION)
			{
				SymbolFunction SF = (SymbolFunction) S;
				cBlock.addOSFInst(CGUtils.getInvocDir(),st.level-S.nivel,SF.etiq);
			}

			if(S.type == Symbol.Types.ARRAY)
			{
				SymbolArray SA = (SymbolArray) S;

				if(SA.minInd<0)
				{
					cBlock.addInst(PCodeInstruction.OpCode.STC,-SA.minInd);
					cBlock.addInst(PCodeInstruction.OpCode.NGI);
					cBlock.addInst(PCodeInstruction.OpCode.SBT);
				}
				else if(SA.minInd>0)
				{
					cBlock.addInst(PCodeInstruction.OpCode.STC,SA.minInd);
					cBlock.addInst(PCodeInstruction.OpCode.SBT);
				}
				

			}

	} 	
	(<tASIG>
	{
		cBlock.addInst(PCodeInstruction.OpCode.SRF,(st.level - S.nivel),(int)S.dir);

		if(S.parClass==Symbol.ParameterClass.REF)
		{
			cBlock.addInst(PCodeInstruction.OpCode.DRF);
		}
		
		if(S instanceof SymbolArray)
		{
			SymbolArray SA = (SymbolArray) S;

			cBlock.addInst(PCodeInstruction.OpCode.PLUS);
			
		}

	} expresion(at, cBlock) 
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		sf.checkTypesAsignacion(at,at2);
		at = new Attributes();
		at2 = new Attributes();

		cBlock.addInst(PCodeInstruction.OpCode.ASG);
	}
	)?
	{
	}
}

void inst_if(Attributes att,CodeBlock cBlock):
{
	Attributes at = new Attributes();
	CodeBlock cbloque=new CodeBlock();

	String endLabel = CGUtils.newLabel();
	String lbel = null;
}
{
	<tIF> expresion(at, cBlock)
	{
		if(at.type==Symbol.Types.ARRAY)
		{
			Attributes aux = at.atts.get(0);
			for(int i=0; i<6 && aux.atts.size()>0; i++)
			{
				aux = aux.atts.get(0);	
			}
			if(aux.type!=Symbol.Types.INT)
			{
				throw new ErrorSemantico("No puedes comparar un array entero con un booleano");
			}
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("El array tienen que devolver un booleano: "+at.type);
			}
		} 
		else if(at.type== Symbol.Types.FUNCTION)
		{
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("La funcion tienen que devolver un booleano: "+at.type);
			}
		}
		else if(at.type!=Symbol.Types.BOOL)
		{
			throw new ErrorSemantico("Solo se admiten expresiones booleanas: "+at.type);
		}

		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();

		for(Attributes a : att.atts)
		{
			System.out.println(a.code);
		}

		lbel = CGUtils.newLabel();
		cBlock.addInst(PCodeInstruction.OpCode.JMF,lbel);

		cBlock.addComment("Inicio Bloque de instrucciones IF");
	}
	<tTHEN> instrucciones(cbloque)
	{
		cBlock.addBlock(cbloque);
		cbloque=new CodeBlock();
		cBlock.addComment("Fin Bloque de instrucciones IF");
		cBlock.addInst(PCodeInstruction.OpCode.JMP,endLabel);
		cBlock.addLabel(lbel);
	} ((<tELSIF> expresion(at, cBlock)
	{
		

		if(at.type==Symbol.Types.ARRAY)
		{
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("El array tienen que devolver un booleano: "+at.type);
			}
		} 
		else if(at.type== Symbol.Types.FUNCTION)
		{
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("La funcion tienen que devolver un booleano: "+at.type);
			}
		}
		else if(at.type!=Symbol.Types.BOOL)
		{
			throw new ErrorSemantico("Solo se admiten expresiones booleanas: "+at.type);
		}
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();

		lbel = CGUtils.newLabel();
		cBlock.addInst(PCodeInstruction.OpCode.JMF,lbel);
		cBlock.addComment("Inicio Bloque de instrucciones ELSIF");
	}
	<tTHEN> instrucciones(cbloque)
	{
		cBlock.addBlock(cbloque);
		cbloque=new CodeBlock();
		cBlock.addComment("Fin Bloque de instrucciones ELSIF");
		cBlock.addInst(PCodeInstruction.OpCode.JMP,endLabel);
		cBlock.addLabel(lbel);
	})* 
	(<tELSE> 
	{
		cBlock.addComment("Inicio Bloque de instrucciones ELSE");
	}
	instrucciones(cbloque)
	{
		cBlock.addBlock(cbloque);
		cbloque=new CodeBlock();
		cBlock.addComment("Fin Bloque de instrucciones ELSE");
		cBlock.addInst(PCodeInstruction.OpCode.JMP,endLabel);
	})?) 
	<tENDIF>
	{
		cBlock.addLabel(endLabel);
	}
} 

void inst_while(Attributes att,CodeBlock cBlock):
{
	Attributes at = new Attributes();

	CodeBlock cbloque=new CodeBlock();

	String initLabel = CGUtils.newLabel();
	String endLabel = CGUtils.newLabel();
}
{
	<tWHILE>
	{
		cBlock.addLabel(initLabel);
	}
	expresion(at, cBlock)
	{
		if(at.type==Symbol.Types.ARRAY || at.type==Symbol.Types.FUNCTION)
		{
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("Solo se admiten expresiones booleanas: "+at.type);
			}
		}
		else if(at.type!=Symbol.Types.BOOL)
		{
			throw new ErrorSemantico("Solo se admiten expresiones booleanas: "+at.type);
		}
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);

		cBlock.addInst(PCodeInstruction.OpCode.JMF,endLabel);
	}
	<tLOOP> instrucciones(cbloque) <tENDLOOP>
	{
		cBlock.addComment("Inicio Bloque de instrucciones While");
		cBlock.addBlock(cbloque);
		cBlock.addComment("Fin Bloque de instrucciones While");
		cBlock.addInst(PCodeInstruction.OpCode.JMP,initLabel);
		cBlock.addLabel(endLabel);
		//System.err.println("Expresion while condicion: " + att);
	}
}

void inst_return(Attributes att,CodeBlock cBlock):{
	Attributes at = new Attributes();
}
{
	<tRETURN> expresion(at, cBlock)
	{
		try{
			Symbol S = st.getSymbol(tipoReturn.get(tipoReturn.size()-1).image);
			sf.add_to_atts(att,at);
			
			if(S.type != Symbol.Types.FUNCTION){
				throw new ErrorSemantico("Solo se puede hacer return en funciones");
			} 
			if(at.type == Symbol.Types.FUNCTION)
			{
				if(at.extraType!=((SymbolFunction)S).returnType)
				{
					throw new ErrorSemantico("Error de tipos en return");
				}
			} 
			else if(at.type != ((SymbolFunction)S).returnType)
			{

				throw new ErrorSemantico("Error de tipos en return");
			}
			
			at = new Attributes();

			cBlock.addInst(PCodeInstruction.OpCode.CSF);
		} catch(SymbolNotFoundException ex) {
			throw new ErrorSemantico("Error semantico. Funcion no encontrada");
		}
	}
}

void inst_null(Attributes att,CodeBlock cBlock):{}
{
	<tNULL> {cBlock.addComment("Bloque sin instrucciones");}
}


void expresion(Attributes att, CodeBlock cBlock):
{
	Boolean esBool = false; 
	Attributes at = new Attributes();
	CodeBlock cExp = new CodeBlock();
}
{
    relacion(at, cExp)
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();

		cBlock.addBlock(cExp);
		cExp = new CodeBlock();
	}
	( ((<tAND>) 
	{
		att.type = Symbol.Types.BOOL;
		esBool = true;
	}
	relacion(at, cExp) 
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();

		cBlock.addBlock(cExp);
		cBlock.addInst(PCodeInstruction.OpCode.AND);
		cExp = new CodeBlock();
	}
	)+
	|
	((<tOR>) 
	{
		att.type = Symbol.Types.BOOL;
		esBool = true;
	}
	relacion(at, cExp) 
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();

		cBlock.addBlock(cExp);
		cBlock.addInst(PCodeInstruction.OpCode.OR);
		cExp = new CodeBlock();
	}
	)+ )?
	{
		// ( 2+3+4) + 5 + (2+3)
		// Expresion
		//  (2+3+4)
		//   5
		//  (2+3)
		if(esBool)
		{
			 for(Attributes a : att.atts)
			 {
				//System.err.println(a.type);
				if(a.type == Symbol.Types.FUNCTION || a.type == Symbol.Types.ARRAY){
					if(a.extraType!=Symbol.Types.BOOL)
					{
						throw new ErrorSemantico("Error de tipos");
					}
					if(a.type == Symbol.Types.ARRAY){
						Attributes aux = a.atts.get(0);
						for(int i=0; i<5 && aux.atts.size()>0; i++)
						{
							aux = aux.atts.get(0);	
							//System.err.println(aux.type);
						}
						if(aux.type!=Symbol.Types.INT)
						{
							throw new ErrorSemantico("No puedes comparar un array entero con un booleano");
						}
					}
				} else{
					if(a.type!=Symbol.Types.BOOL)
					{
						throw new ErrorSemantico("Error de tipos");
					}
				}
			 }
			 //System.out.println();
		}
		
	}
}

void relacion(Attributes att, CodeBlock cBlock):
{
	//Attributes atTypes = new Attributes();
	Boolean tieneOpInts = null;
	Attributes at = new Attributes();
	CodeBlock cRel = new CodeBlock();
}
{
    expresion_simple(at, cBlock)
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
	}
 	( tieneOpInts = operador_relacional(cRel)
	expresion_simple(at, cBlock)
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		
	} 
	)? 
	{
		cBlock.addBlock(cRel);

		if(tieneOpInts!=null)
		{
			att.type = Symbol.Types.BOOL;
			if(tieneOpInts)
			{
				//System.err.println("Operador relacional: " + att);
				for(Attributes a : att.atts)
			 	{
					if (a.type==Symbol.Types.ARRAY || a.type==Symbol.Types.FUNCTION)
					{
						if(a.extraType!=Symbol.Types.INT)
						{
							throw new ErrorSemantico("Error de tipos. Se esperaban integers en relacion: "+a.type);
						}
					} else if(a.type!=Symbol.Types.INT)
			 		{
			 			throw new ErrorSemantico("Error de tipos. Se esperaban integers en relacion: "+a.type);
			 		}
			 	}
			} else {
				if(at.type != Symbol.Types.UNDEFINED) 
				{
					Attributes a2 = att.atts.get(att.atts.size()-2);
					if(a2.type == Symbol.Types.FUNCTION || a2.type == Symbol.Types.ARRAY)
					{
						if(a2.extraType!=at.type)
						{
							throw new ErrorSemantico("Error de tipos. Se esperaban el mismo tipo en relacion: " + a2.extraType + " y "+ at.type);
						}
					} else if(at.type == Symbol.Types.FUNCTION || at.type == Symbol.Types.ARRAY)
					{
						if(a2.type!=at.extraType)
						{
							throw new ErrorSemantico("Error de tipos. Se esperaban el mismo tipo en relacion: " + a2.type + " y "+ at.extraType);
						}
					}
					else if(a2.type!=at.type)
					{
						throw new ErrorSemantico("Error de tipos. Se esperaban el mismo tipo en relacion: " + a2.type + " y "+ at.type);
					}
				}
			}
		}
	}
}

Boolean operador_relacional(CodeBlock cBlock):
{
	
}
{    
	<tEQ>    {cBlock.addInst(PCodeInstruction.OpCode.EQ);return false;}// Char,bool,int
	| <tLS>  {cBlock.addInst(PCodeInstruction.OpCode.LT);return true;}// Int
	| <tGT>  {cBlock.addInst(PCodeInstruction.OpCode.GT);return true;}// Int
	| <tLE>  {cBlock.addInst(PCodeInstruction.OpCode.LTE);return true;}// Int
	| <tGE>  {cBlock.addInst(PCodeInstruction.OpCode.GTE);return true;}// Int
	| <tNEQ> {cBlock.addInst(PCodeInstruction.OpCode.NEQ);return false;}// Char,bool,int
}

void expresion_simple(Attributes att, CodeBlock cBlock):
{
	boolean esInt=false;
	Attributes at = new Attributes();
	CodeBlock cOP = new CodeBlock();
}
{
	(( <tADD> |	<tSUB>{cOP.addInst(PCodeInstruction.OpCode.NGI);})
	{
		esInt=true;att.type=Symbol.Types.INT;
	})? 
    termino(at, cBlock)
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at); 
		at = new Attributes();

		cBlock.addBlock(cOP);
		cOP = new CodeBlock();
	}
	( ( <tADD>{cOP.addInst(PCodeInstruction.OpCode.PLUS);} | <tSUB>{cOP.addInst(PCodeInstruction.OpCode.SBT);}) 
	termino(at, cBlock) 
	{	
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
		att.type = Symbol.Types.INT;
		//System.err.println("Expresion simple: " + att);
		for(Attributes a : att.atts)
		{
			if(a.type == Symbol.Types.FUNCTION || a.type == Symbol.Types.ARRAY)
			{
				if(a.extraType!=Symbol.Types.INT)
				{
					throw new ErrorSemantico("Error de tipos. Se esperaban integers en expresion simple: " + a.type);
				}
			} else if(a.type!=Symbol.Types.INT)
			{
				throw new ErrorSemantico("Error de tipos. Se esperaban integers en expresion simple: " + a.type);
			}
		}

		cBlock.addBlock(cOP);
		cOP = new CodeBlock();
	})*
}

void termino(Attributes att, CodeBlock cBlock):
{
	Attributes at = new Attributes();
	CodeBlock opMUL = new CodeBlock();
}
{
    factor(at, cBlock) 
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
	}
	( operador_multiplicativo(opMUL) factor(at, cBlock)
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		att.type = Symbol.Types.INT;
		at = new Attributes();
		
		for(Attributes a : att.atts)
		{
			if(a.type == Symbol.Types.FUNCTION || a.type == Symbol.Types.ARRAY)
			{
				if(a.extraType!=Symbol.Types.INT)
				{
					throw new ErrorSemantico("Error de tipos. Se esperaban integers en termino: " + att.atts.get(0).type);
				}
			} else if(a.type!=Symbol.Types.INT)
			{
				throw new ErrorSemantico("Error de tipos. Se esperaban integers en termino: " + att.atts.get(0).type);
			}
		}

		cBlock.addBlock(opMUL);
		opMUL = new CodeBlock();
	}
	
	)*
}

void operador_multiplicativo(CodeBlock cBlock):
{}
{
    <tMUL>{cBlock.addInst(PCodeInstruction.OpCode.TMS);} 
	| <tMOD>{cBlock.addInst(PCodeInstruction.OpCode.MOD);} 
	| <tDIV>{cBlock.addInst(PCodeInstruction.OpCode.DIV);}
}

void factor(Attributes att, CodeBlock cBlock):
{
	Attributes at = new Attributes();
}
{
    primario(at, cBlock) 
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		at = new Attributes();
		
	}

|   <tNOT>  primario(at, cBlock)
	{
		att.type = Symbol.Types.BOOL;
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
		if(at.type == Symbol.Types.ARRAY)
		{
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("El array tienen que devolver un booleano: "+at.type);
			}
		} 
		else if(at.type == Symbol.Types.FUNCTION)
		{
			if(at.extraType!=Symbol.Types.BOOL)
			{
				throw new ErrorSemantico("La funcion tienen que devolver un booleano: "+at.type);
			}
		}
		else if(at.type!=Symbol.Types.BOOL)
		{
			throw new ErrorSemantico("Solo se admiten expresiones booleanas: "+at.type);
		}
		at = new Attributes();

		cBlock.addInst(PCodeInstruction.OpCode.NGB);
	}
}

void primario(Attributes att, CodeBlock cBlock) :
{ 
	Attributes at = new Attributes();

	Token t;
	Symbol S;
	boolean minus = false;
}
{
	<tAP> expresion(at, cBlock) <tCP> 
	{
		sf.add_to_atts(att,at);
		sf.heredar_valores(att,at);
	}
|   <tINT2CHAR> <tAP> expresion(at, cBlock) <tCP> 
	{
		if(at.type!=Symbol.Types.INT)
		{
			throw new ErrorSemantico("int2char solo acepta enteros");
		}
		if(at.atts.size()!=1){
			throw new ErrorSemantico("int2char solo acepta un entero");
		}
		
		//cBlock.addInst(PCodeInstruction.OpCode.ASG);

		sf.asignar_valores(att,at,at.code,Symbol.Types.CHAR, Symbol.ParameterClass.VAL, st.level, true);
		sf.heredar_valores(att,at);
	}
|   <tCHAR2INT> <tAP> expresion(at, cBlock) <tCP> 
	{
		if(at.type!=Symbol.Types.CHAR)
		{
			throw new ErrorSemantico("char2int solo acepta caracteres");
		}
		if(at.atts.size()!=1){
			throw new ErrorSemantico("char2int solo acepta un caracter");
		}

		sf.asignar_valores(att,at,"char2int(" + at.code + ")",Symbol.Types.INT, Symbol.ParameterClass.VAL, st.level,true);
		sf.heredar_valores(att,at);
	}
|   t=<tID>
	{
		try
		{
			t.image = t.image.toLowerCase();
			S = st.getSymbol(t.image);
		}
		catch(SymbolNotFoundException ex)
		{
			throw new ErrorSemantico(t.image + " no existe.");
		}
	}
	(<tAP> (function_call(at,cBlock,S)) <tCP> )?  
	{
			sf.cambiarTipos(at, S);
			sf.asignar_valores(att,at,t.image,S.type, S.parClass, st.level,false);
			sf.checkPrimarioIds(at);
			

			if(S instanceof SymbolProcedure)
			{
				SymbolProcedure SP = (SymbolProcedure) S;
				cBlock.addOSFInst(CGUtils.getInvocDir(),st.level-S.nivel,SP.etiq);
			}
			else if(S instanceof SymbolFunction)
			{
				SymbolFunction SF = (SymbolFunction) S;
				cBlock.addOSFInst(CGUtils.getInvocDir(),st.level-S.nivel,SF.etiq);
			}
			else if(S.type == Symbol.Types.ARRAY)
			{
				SymbolArray SA = (SymbolArray) S;

				//cBlock.addComment(at.type+"");

				if(at.type==Symbol.Types.ARRAY)
				{
					cBlock.addComment("Array completo 2");
					//cBlock.addInst(PCodeInstruction.OpCode.SRF,(st.level - S.nivel),(int)S.dir);

					cBlock.addInst(PCodeInstruction.OpCode.SRF,(st.level - S.nivel),(int)S.dir);
					
					if(S.parClass == Symbol.ParameterClass.REF)
					{
						cBlock.addInst(PCodeInstruction.OpCode.DRF);
					}
				}else
				{
					cBlock.addComment("Componente Array");
					if(SA.minInd<0)
					{
						cBlock.addInst(PCodeInstruction.OpCode.STC,-SA.minInd);
						cBlock.addInst(PCodeInstruction.OpCode.NGI);
						cBlock.addInst(PCodeInstruction.OpCode.SBT);
					}
					else if(SA.minInd>0)
					{
						cBlock.addInst(PCodeInstruction.OpCode.STC,SA.minInd);
						cBlock.addInst(PCodeInstruction.OpCode.SBT);
					}

					cBlock.addInst(PCodeInstruction.OpCode.SRF,(st.level - S.nivel),(int)S.dir);

					if(S.parClass == Symbol.ParameterClass.REF)
					{
						cBlock.addInst(PCodeInstruction.OpCode.DRF);
					}
						
					if(at.type!=Symbol.Types.ARRAY)
					{
						cBlock.addInst(PCodeInstruction.OpCode.PLUS);
						cBlock.addInst(PCodeInstruction.OpCode.DRF);
					}
				}

				

				

				at = new Attributes();
				
				
			}
			else
			{
				cBlock.addInst(PCodeInstruction.OpCode.SRF,st.level-S.nivel,(int)S.dir);
				cBlock.addInst(PCodeInstruction.OpCode.DRF);
			}

	}
|   ("-"{minus = true;})? t= <tCONST_INT> 
    {
		cBlock.addInst(PCodeInstruction.OpCode.STC, Integer.parseInt(t.image));
		if(minus){cBlock.addInst(PCodeInstruction.OpCode.NGI);}
		sf.asignar_valores(att,at,t.image,Symbol.Types.INT, Symbol.ParameterClass.VAL, st.level,true);
	}
|   t= <tCONST_CHAR> 
	{
		char charValue = t.image.charAt(1);
		cBlock.addInst(PCodeInstruction.OpCode.STC, (int) charValue);
		sf.asignar_valores(att,at,t.image,Symbol.Types.CHAR, Symbol.ParameterClass.VAL, st.level,true);
	}
|   t= <tCONST_STRING> 
	{
		// cBlock.addInst(PCodeInstruction.OpCode.STC, Integer.parseInt(t.image));
		sf.asignar_valores(att,at,t.image,Symbol.Types.STRING, Symbol.ParameterClass.VAL, st.level,true);
	}
|   t= <tTRUE>	
	{
		cBlock.addInst(PCodeInstruction.OpCode.STC, 1);
		sf.asignar_valores(att,at,"true",Symbol.Types.BOOL, Symbol.ParameterClass.VAL, st.level,true);
	}
|   t= <tFALSE> 
	{
		cBlock.addInst(PCodeInstruction.OpCode.STC, 0);
		sf.asignar_valores(att,at,"false",Symbol.Types.BOOL, Symbol.ParameterClass.VAL, st.level,true);
	}
}


void function_call(Attributes att,CodeBlock cBloque,Symbol S) :
{ 
	Attributes at = new Attributes();
	CodeBlock cBlock = new CodeBlock();
	int i=0;
}
{
 ( expresion(at, cBlock)
 {
	//System.out.println(at.parClass);

	//System.out.println(at.toString());

	if(S instanceof SymbolProcedure)
	{
		SymbolProcedure SP = (SymbolProcedure) S;
		//System.out.println(SP.parList.get(i).parClass);
		at.parClass = SP.parList.get(i).parClass;
		i++;
	}

	if(S instanceof SymbolFunction)
	{
		SymbolFunction SF = (SymbolFunction) S;
		//System.out.println(SF.parList.get(i).parClass);
		at.parClass = SF.parList.get(i).parClass;
		i++;
	}

	sf.add_to_atts(att,at);
	sf.heredar_valores(att,at);
	
	if(at.esConstante&&at.parClass==Symbol.ParameterClass.REF)
	{
		throw new ErrorSemantico("No puedes pasar una constante como valor por referencia");
	}

	//System.out.println(at.parClass);	

	if(at.type==Symbol.Types.ARRAY&&at.parClass==Symbol.ParameterClass.VAL)
	{
		SymbolArray SA = null;

		try
		{
			SA = (SymbolArray)st.getSymbol(at.code);
		} catch(SymbolNotFoundException ex)
		{
			throw new ErrorSemantico(at.code+" no existe");
		}
		
		for(int j=1;j<SA.maxInd-SA.minInd+1;j++)
		{
			cBlock.addInst(PCodeInstruction.OpCode.SRF,(st.level - SA.nivel),(int)SA.dir+j);
			cBlock.addInst(PCodeInstruction.OpCode.DRF);
		}
	}

	cBloque.addBlock(cBlock);
	cBlock = new CodeBlock();

	at = new Attributes();
 } 
 ((<tCOMA>) expresion(at, cBlock)
 {
	if(S instanceof SymbolProcedure)
	{
		SymbolProcedure SP = (SymbolProcedure) S;
		//System.out.println(SP.parList.get(i).parClass);
		at.parClass = SP.parList.get(i).parClass;
		i++;
	}

	if(S instanceof SymbolFunction)
	{
		SymbolFunction SF = (SymbolFunction) S;
		//System.out.println(SF.parList.get(i).parClass);
		at.parClass = SF.parList.get(i).parClass;
		i++;
	}

	sf.add_to_atts(att,at);
	sf.heredar_valores(att,at);

	if(at.esConstante&&at.parClass==Symbol.ParameterClass.REF)
	{
		throw new ErrorSemantico("No puedes pasar una constante como valor por referencia");
	}
	
	//System.out.println(at.parClass);
	if(at.type==Symbol.Types.ARRAY&&at.parClass==Symbol.ParameterClass.VAL)
	{
		SymbolArray SA = null;

		try
		{
			SA = (SymbolArray)st.getSymbol(at.code);
		} catch(SymbolNotFoundException ex)
		{
			throw new ErrorSemantico(at.code+" no existe");
		}
		
		for(int j=1;j<SA.maxInd-SA.minInd+1;j++)
		{
			cBlock.addInst(PCodeInstruction.OpCode.SRF,(st.level - SA.nivel),(int)SA.dir+j);
			cBlock.addInst(PCodeInstruction.OpCode.DRF);
		}
	}

	cBloque.addBlock(cBlock);
	cBlock = new CodeBlock();

	at = new Attributes();
}
)* 
 ) 
 {
	
 }
}


void tipo_variable(Attributes atTypes, Attributes atIsArray):
{ 
	Token i;
	Boolean esNegativo = false;
}
{
	< tARRAY >
	<tAP>
	("-" {esNegativo=true;})? i = < tCONST_INT >
		{
			if(esNegativo)	atTypes.inicio = -Integer.parseInt(i.image);
			else atTypes.inicio = Integer.parseInt(i.image);
			esNegativo = false;
			
			//at.parList.add(new Symbol(i.image,Symbol.Types.INT));
			
		}
	("..")
	("-"{esNegativo=true;})? i = < tCONST_INT >
		{
			if(esNegativo)	atTypes.fin = -Integer.parseInt(i.image);
			else atTypes.fin = Integer.parseInt(i.image);
			// at.parList.add(new Symbol(i.image,Symbol.Types.INT));
			atTypes.type = Symbol.Types.ARRAY;
			esNegativo = false;
		}
	<tCP>
	 <tOF> tipo_variable_simple(atIsArray)
|   tipo_variable_simple(atTypes)
}

void tipo_variable_simple(Attributes at):
{

}
{
		< tBOOL > 
			{
				at.type = Symbol.Types.BOOL;
			}
	|	< tCHAR >
			{
				at.type = Symbol.Types.CHAR;
			}
	|	< tINT >
			{
				at.type = Symbol.Types.INT;
			}
}

