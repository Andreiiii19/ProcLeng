//*****************************************************************
// File:   cl.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
// Date:   julio 2023
// Coms:   compilar mediante "ant"
//*****************************************************************

options {
	IGNORE_CASE = true;
	COMMON_TOKEN_ACTION = true;
}

PARSER_BEGIN(alike)

package traductor;

//...

import lib.symbolTable.*;
import lib.attributes.*;
import lib.symbolTable.exceptions.*;
import java.util.ArrayList;
import lib.errores.*;
import lib.tools.SemanticFunctions;

public class alike { 


	static SymbolTable st;

	private static void initSymbolTable() {
		boolean b;
		String[] palsRes = {
	    	"array","boolean","character","integer","procedure","if","then","elsif","else","end",
			"while","loop","begin","ref","of","is","not","put_line","put","return","and","or",
			"mod","skip_line","function","null","get","true","false","int2char","char2int"
		};

		st = new SymbolTable();

		st.insertReservedWords(palsRes);
	}

   public static void main(String[] args) {
	   alike parser = null;
	   SemanticFunctions sf = new SemanticFunctions();
	   initSymbolTable();
	   
	   try {
		   if(args.length == 0) {
			   parser = new alike(System.in);
		   }
		   else {
			   parser = new alike(new java.io.FileInputStream(args[0]));
		   }
		   //Programa es el símbolo inicial de la gramática
		   parser.Programa();
		   //System.out.println(st.toString());
		   //...
		   System.out.println("***** Análisis terminado con éxito *****");
	   }
	   catch (java.io.FileNotFoundException e) {
		   System.err.println ("Fichero " + args[0] + " no encontrado.");
	   }
	   catch (TokenMgrError e) {
		   System.err.println("LEX_ERROR: " + e.getMessage());
	   }
	   catch (ParseException e) {
            System.err.println("PARSER_ERROR: " + e.getMessage());
        }
	   //...
   }
}
PARSER_END(alike)

TOKEN_MGR_DECLS : {
	static void CommonTokenAction(Token token) {
		System.err.println("(" + token.beginLine + ", "
					+ token.beginColumn + "): "+ alikeConstants.tokenImage[token.kind] + " " + token.image);
	}

}

SPECIAL_TOKEN : {
	< tCOMMENT: (<COMMENT>) >
}

TOKEN : {
	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|	< #CHAR: (~["\\"]) >
|	< #STRING: (~["\\","\""]|("\"\""))+ >
|	< #COMMENT: ("--")(~["\n"])*("\n") >
}

TOKEN : {
	< tBOOL: "boolean" >
|	< tCHAR: "character" >
|	< tINT: "integer" >
|	< tARRAY: "array" >
|	< tPROC: "procedure" >
|	< tIF:	"if" >
|	< tTHEN: "then" >
|	< tELSIF: "elsif" >
|	< tELSE: "else" >
|	< tENDIF: "end"(" ")+"if"> 
| 	< tEND: "end" >
|	< tWHILE: "while" >
|	< tLOOP: "loop" >
|	< tENDLOOP: "end loop" >
|	< tBEGIN: "begin" >
|	< tREF: "ref" >
|	< tOF: "of" >
|	< tIS: "is" >
|	< tNOT: "not" >
| 	< tPC: ";" >
|	< tPLINE: "put_line" >
|	< tPUT: "put" >
|	< tRETURN: "return" >
|	< tAP: "(" >
|	< tCP: ")" >
|	< tASIG: ":=" >
|	< tGE: ">=" >
|	< tLE: "<=" >
|	< tNEQ: "/=" >
|	< tEQ: "=" >
|	< tGT: ">" >
|	< tLS: "<" >
|	< tDP: ":" >
|	< tAND: "and" >
|	< tOR: "or" >
|	< tADD: "+" >
|	< tSUB: "-" >
|	< tDIV: "/" >
|	< tMUL: "*" >
|	< tCOMA: "," >
|	< tMOD: "mod" >
|	< tSKIP: "skip_line" >
|	< tFUNC : "function" >
|	< tNULL : "null" >
|	< tGET : "get" >
|	< tTRUE : "true" >
|	< tFALSE : "false" >
|	< tINT2CHAR : "int2char" >
|	< tCHAR2INT : "char2int" >
|	< tCONST_CHAR : ("'")(< CHAR >)("'") >
|	< tCONST_INT : ("-")?(< DIGIT >)+ >
|	< tCONST_STRING : ("\"")(< STRING >)*("\"") >
| 	< tID: (< LETTER >| "_")+(< DIGIT >| "_" | < LETTER >)* > 
}

SKIP : 
{
	" "
|	"\t"
|	"\n"
|	"\r" 
}





//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void Programa():
{
	Token name;
	Attributes at = new Attributes();
} 
{
	<tPROC>
	name = <tID>
	(<tAP> parametros_formales(at) <tCP>)?
	<tIS>
	( declaracion_variables() )?
	( (declaracion_procs_funcs())+ )?
	<tBEGIN>
	instrucciones()
	<tEND>
	<tPC>
}

void declaracion_procedimiento():
{
	Token name;
	Attributes att = new Attributes();
}
{
	name = cabecera_procedimiento(att)
	( declaracion_variables() )?
	( declaracion_procs_funcs() )?
	<tBEGIN>
	instrucciones()
	<tEND>
	<tPC> 
	{
		//System.err.println("Bloque" + name.image + "terminado \n" + st.toString());
		st.removeBlock();
	}
}

void declaracion_funcion():
{
	Attributes atType = new Attributes();
	Attributes atIsArray = new Attributes();
	Attributes atts = new Attributes();
	Token name;
}
{
	name = cabecera_funcion(atType,atIsArray,atts)
	( declaracion_variables() )?
	( declaracion_procs_funcs() )?
	<tBEGIN>
	{
		
	}
	instrucciones()
	<tEND>
	<tPC>
	{
		//System.err.println("Bloque " + name.image + " terminado \n"+ st.toString());
		st.removeBlock();
		if(atType.type == Symbol.Types.ARRAY)
		{
			throw new ErrorSemantico("No se permiten funciones con retorno de vectores");
		}
	}
}

void declaracion_procs_funcs():
{}
{
	declaracion_procedimiento()
	| declaracion_funcion()
}

void instrucciones():
{}
{
	(instruccion()(";"))+
}


void declaracion_variables():
{

}
{
	( declaracion_var() ";")+
}

ArrayList<Symbol> declaracion_var():
{
	Attributes atType = new Attributes();
	Attributes atIsArray = new Attributes();
	ArrayList<Token> tokens;
	ArrayList<Symbol> symbols = new ArrayList<Symbol>();
}
{
		tokens = lista_ids()
		<tDP>
		(	
		<tREF>
			{
				atType.parClass = Symbol.ParameterClass.REF;
			}
		)?
		tipo_variable(atType,atIsArray)
		{	
			if(atType.parClass==Symbol.ParameterClass.NONE)atType.parClass=Symbol.ParameterClass.VAL;
			for(Token t : tokens)
			{
				Symbol S = null;

				
				//System.out.println(atType.type + " " + atIsArray.type);
				if(atType.type == Symbol.Types.BOOL) S = new SymbolBool(t.image, atType.parClass);
				if(atType.type == Symbol.Types.CHAR) S = new SymbolChar(t.image, atType.parClass);
				if(atType.type == Symbol.Types.INT) S = new SymbolInt(t.image, atType.parClass);
				if(atType.type == Symbol.Types.ARRAY) 
				{
					
					S = new SymbolArray(t.image, atType.inicio,atType.fin,atIsArray.type,atType.parClass);
				}

				symbols.add(S);
				
				try {
					st.insertSymbol(S);
				} catch (AlreadyDefinedSymbolException e)
				{
					System.err.println("Error semantico. Simbolo ya existente");
				}
			}

			return symbols;
		}
}

ArrayList<Token> lista_ids():
{
	ArrayList<Token> tokens = new ArrayList<Token>();
	Token t;
}
{
	(
		t=<tID>
			{
				if(!st.isReservedWord(t.image))
				{
					tokens.add(t);
				}
				else
				{
					throw new ErrorSemantico("ID no valido. Es una palabra reservada");
				}

			}
	)
	(
		<tCOMA>
		t=<tID>
			{
				if(!st.isReservedWord(t.image)) tokens.add(t);
				else throw new ErrorSemantico("ID no valido. Es una palabra reservada");
			}
	)*
		{
			System.err.println("Lista de ids ");
			return tokens;
		}
}

void lista_ids_o_string_o_inv(Attributes att):
{
	Attributes at = new Attributes();
}
{
	expresion(at)
	{
		att.atts.add(at.clone());
		at = new Attributes();
	}
	(<tCOMA> expresion(at) 
	{
		att.atts.add(at.clone());
		at = new Attributes();
	})*
	{
		att.type = att.atts.get(0).type;
		String _code="";
		for (Attributes a : att.atts)
		{
			_code += a.code + ",";
		}
		att.code = _code;
		att.nivel = st.level;
	}
}


Token cabecera_procedimiento(Attributes att):
{
	Token name;
}
{
	<tPROC>
	name = <tID>
	{
		try {
			Symbol S = new SymbolProcedure(name.image,att.parList);
			st.insertSymbol(S);
			st.insertBlock();
		}catch (AlreadyDefinedSymbolException ex)
		{
			System.err.println("Error semantico. Simbolo ya existente");
		}
	}
	(<tAP> 
	parametros_formales(att)
	<tCP>)?
	<tIS>
	{
		return name;
	}
}

Token cabecera_funcion(Attributes atType,Attributes atIsArray,Attributes atts):
{
	Token name;
	SymbolFunction S = null;
}
{
	<tFUNC>
	name = <tID>
	{
		try{ 
			S = new SymbolFunction(name.image,atts.parList,atType.type);
			st.insertSymbol(S);
			st.insertBlock();
		} catch (AlreadyDefinedSymbolException ex)
		{
			System.err.println("Error semantico. Simbolo ya existente");
		}
		
	}
	(<tAP> parametros_formales(atts) <tCP>)?
	<tRETURN>
	tipo_variable(atType,atIsArray)
	<tIS>
	{
		S.returnType = atType.type;
		return name;
	}
}

void parametros_formales(Attributes att): 
{
	ArrayList<Symbol> symbols;
}
{
	symbols = declaracion_var()
	{
		// try {
			for(Symbol S : symbols)
			{
				att.parList.add(S);
		// 		st.insertSymbol(S);
			}
		// } catch (AlreadyDefinedSymbolException ex)
		// {
		// 	System.err.println("Error semantico. Simbolo ya existente");
		// }
	}
	(<tPC> 
	symbols = declaracion_var()
	{
		for(Symbol S : symbols)
		{
			att.parList.add(S);
			// st.insertSymbol(S);
		}
	}
	)*
}


void instruccion() :
{
	Attributes att = new Attributes();	
}
{
		inst_leer(att)
	|   inst_saltar_linea(att)
	|	inst_escribir(att)
	|   inst_escribir_linea(att)
	|   inst_invocacion_o_asignacion(att)
	|   inst_if(att)
	|   inst_while(att)
	|   inst_return(att)
	|   inst_null(att)
}

void inst_leer(Attributes att):
{}{<tGET> <tAP> lista_ids() <tCP>{System.err.println("Expresion: " + att);}}

void inst_saltar_linea(Attributes att):
{}{<tSKIP>{System.err.println("Expresion: " + att);}}

void inst_escribir(Attributes att):
{}{<tPUT> <tAP> lista_ids_o_string_o_inv(att)  <tCP>{System.err.println("Expresion: " + att);}}

void inst_escribir_linea(Attributes att):
{}{<tPLINE> ((<tAP> lista_ids_o_string_o_inv(att) <tCP>))?{System.err.println("Expresion: " + att);}}

void inst_invocacion_o_asignacion(Attributes att):
{
	Attributes at = new Attributes();
	Attributes at2 = new Attributes();
	Token t;
}
{
	{System.err.println("Invocacion o asignacion");}
	t = <tID>
	{
		Symbol S = st.getSymbol(t.image);
		System.err.println("Encontrado " + S);
			// System.err.println("Token id " + t.image);
			// System.err.println("Function call");
		at2.type = S.type;
		at2.code = (t.image);
		at2.nivel = st.level;
		att.atts.add(at2.clone());
		at = new Attributes();
	} 
	(<tAP> (function_call(at)) 
	{
		att.code = at.code;
		att.atts.add(at.clone());
		at = new Attributes();
	} 
	<tCP>)? 	
	(<tASIG> expresion(at) 
	{
		att.atts.add(at.clone());
		at = new Attributes();
	}
	)?
	{
		String _code="";
		int size = att.atts.size();
		for (int i = 0; i < size; i++) {
			Attributes a = att.atts.get(i);
			_code += a.code;
			if (i < size - 1) { // if this is not the last element
				_code += ",";
			}
		}
		att.code = _code;
		att.type = att.atts.get(0).type;
		System.err.println("Expresion/es de inv o asignacion: " + att);}
}


// void inv_funcion(Attributes att):
// {
// 	Attributes at = new Attributes();
// }
// {
// 	(expresion(at) 
// 	{
// 		att.atts.add(at.clone());
// 	}
// 	(<tCOMA> expresion(at)
// 	{
// 		att.atts.add(at.clone());
// 	}
// 	)*)
// 	{System.err.println("Expresion/es de inv a funcion: " + att);}
// }

void inst_if(Attributes att):
{
	Attributes at = new Attributes();
}
{
	<tIF> expresion(at)
	{
		att.atts.add(at);
		//at = new Attributes();

		if(at.type!=Symbol.Types.BOOL)
		{
			throw new ErrorSemantico("Solo se admiten expresiones booleanas: "+at.type);
		}
	}
	<tTHEN> instrucciones() ((<tELSIF> expresion(at)
	{
		att.atts.add(at);
		//at = new Attributes();

		if(at.type!=Symbol.Types.BOOL)
		{
			throw new ErrorSemantico("Solo se admiten expresiones booleanas: "+at.type);
		}
	}
	<tTHEN> instrucciones())* (<tELSE> instrucciones())?) <tENDIF>
	{
		String _code="";
		int size = att.atts.size();
		for (int i = 0; i < size; i++) {
			Attributes a = att.atts.get(i);
			_code += a.code;
			if (i < size - 1) { // if this is not the last element
				_code += ",";
			}
		}
		att.code = _code;
		System.err.println("Expresion/es de ifs condiciones: " + att);
	}
} 

void inst_while(Attributes att):
{
	Attributes at = new Attributes();
}
{
	<tWHILE> expresion(at)
	{
		att.type = at.type;
		att.atts.add(at);
		//at = new Attributes();
		String _code="";
		int size = att.atts.size();
		for (int i = 0; i < size; i++) {
			Attributes a = att.atts.get(i);
			_code += a.code;
			if (i < size - 1) { // if this is not the last element
				_code += ",";
			}
		}
		att.code = _code;

		if(at.type!=Symbol.Types.BOOL)
		{
			throw new ErrorSemantico("Solo se admiten expresiones booleanas: "+at.type);
		}

	}
	<tLOOP> instrucciones() <tENDLOOP>
	{
		System.err.println("Expresion while condicion: " + att);
	}
}

void inst_return(Attributes att):{
	Attributes at = new Attributes();
}
{
	<tRETURN> expresion(at)
	{
		att.atts.add(at.clone());
		at = new Attributes();
	}
}

void inst_null(Attributes att):{}{<tNULL>{System.err.println("Expresion null");}	}


void expresion(Attributes att):
{
	Boolean esBool = false; 
	Attributes at = new Attributes();
}
{
    relacion(at){if(att.type==Symbol.Types.UNDEFINED){att.type=at.type;}att.atts.add(at);at = new Attributes();}
	( ((<tAND> | <tOR>) 
	{
		att.type = Symbol.Types.BOOL;
		esBool = true;
	}
	relacion(at) {att.atts.add(at);at = new Attributes();}
	)+ )?
	{
		// ( 2+3+4) + 5 + (2+3)
		// Expresion
		//  (2+3+4)
		//   5
		//  (2+3)
		if(esBool)
		{
			 for(Attributes a : att.atts)
			 {
				//System.out.print(a.type + " ");
			 	if(a.type!=Symbol.Types.BOOL)
			 	{
			 		throw new ErrorSemantico("Error de tipos");
			 	}
			 }
			 //System.out.println();
		} else {
			 att.type = att.atts.get(0).type;
		}
		String _code="";
		int size = att.atts.size();
		for (int i = 0; i < size; i++) {
			Attributes a = att.atts.get(i);
			_code += a.code;
			if (i < size - 1) { // if this is not the last element
				_code += ",";
			}
		}
		att.code = _code;
	}
}

void relacion(Attributes att):
{
	//Attributes atTypes = new Attributes();
	Boolean tieneOpInts = null;
	Attributes at = new Attributes();
}
{
    expresion_simple(at){if(att.type==Symbol.Types.UNDEFINED){att.type=at.type;}
	att.atts.add(at);at = new Attributes();}
 	( tieneOpInts = operador_relacional()
	expresion_simple(at){att.atts.add(at);at = new Attributes();} )? 

	{
		if(tieneOpInts!=null)
		{
			att.type = Symbol.Types.BOOL;
			if(tieneOpInts)
			{
				for(Attributes a : att.atts)
			 	{
			 		if(a.type!=Symbol.Types.INT)
			 		{
			 			throw new ErrorSemantico("Error de tipos. Se esperaban integers en relacion: "+
						a.type);
			 		}
			 	}
			}
		}
	}
}

Boolean operador_relacional():
{
	
}
{    
	<tEQ>    {return false;}// Char,bool,int
	| <tLS>  {return true;}// Int
	| <tGT>  {return true;}// Int
	| <tLE>  {return true;}// Int
	| <tGE>  {return true;}// Int
	| <tNEQ> {return false;}// Char,bool,int
}

void expresion_simple(Attributes att):
{
	boolean esInt=false;
	Attributes at = new Attributes();
}
{
	(( <tADD> |	<tSUB> ){esInt=true;att.type=Symbol.Types.INT;})? 
    termino(at){if(att.type==Symbol.Types.UNDEFINED){att.type=at.type;} att.atts.add(at);at = new Attributes();}
	( ( <tADD> | <tSUB> ) termino(at) 
	{
		att.atts.add(at);at = new Attributes();

		att.type = Symbol.Types.INT;
		for(Attributes a : att.atts)
		{
			if(a.type!=Symbol.Types.INT)
			{
				throw new ErrorSemantico("Error de tipos. Se esperaban integers en expresion simple: " + a.type);
			}
		}
	})*
	{
		if(esInt&&att.atts.get(0).type!=Symbol.Types.INT)
		{
			throw new ErrorSemantico(att.atts.get(0).type + "");
		}
	}
}

void termino(Attributes att):
{
	Attributes at = new Attributes();
}
{
    factor(at) {if(att.type==Symbol.Types.UNDEFINED){att.type=at.type;}
	att.type=at.type;att.atts.add(at);at = new Attributes();}
	( operador_multiplicativo() factor(at)
	{
		att.type = Symbol.Types.INT;
		att.atts.add(at);at = new Attributes();
		
		for(Attributes a : att.atts)
		{
			if(a.type!=Symbol.Types.INT)
			{
				throw new ErrorSemantico("Error de tipos. Se esperaban integers en termino: " + att.atts.get(0).type);
			}
		}
	}
	
	)*
}

void operador_multiplicativo():
{}
{
    <tMUL> | <tMOD> | <tDIV>
}

void factor(Attributes att):
{
	Attributes at = new Attributes();
}
{
    primario(at) {if(att.type==Symbol.Types.UNDEFINED){att.type=at.type;}
	att.atts.add(at);at = new Attributes();}
|   <tNOT>  primario(at)
	{
		att.type = Symbol.Types.BOOL;
		att.atts.add(at);
		
		if(at.type!=Symbol.Types.BOOL)
		{
			throw new ErrorSemantico("Error de tipos. Se esperaban bool en primario: " + at.type);
		}
		
		at = new Attributes();
	}
}

void primario(Attributes att) :
{ 
	Attributes at = new Attributes();

	Token t;
	Symbol S;
}
{
	<tAP> expresion(at) <tCP> 
	{
		if(att.type==Symbol.Types.UNDEFINED){att.type=at.type;}
		att.atts.add(at);
		//at = new Attributes();
	}
|   <tINT2CHAR> <tAP> expresion(at) <tCP> 
	{
		att.type = Symbol.Types.CHAR;
		at.code = "int2char(" + at.code + ")";
		att.atts.add(at);
		//at = new Attributes();
		/*for (Attributes a : at.atts)
		{
			if(a.type!=Symbol.Types.INT)
			{
				throw new ErrorSemantico("int2char solo acepta enteros");
			}
		}*/

		if(at.type!=Symbol.Types.INT)
		{
			throw new ErrorSemantico("int2char solo acepta enteros");
		}
	}
|   <tCHAR2INT> <tAP> expresion(at) <tCP> 
	{
		att.type = Symbol.Types.INT;
		at.code = "char2int(" + at.code + ")";
		att.atts.add(at);
		//at = new Attributes();
		
		if(at.type!=Symbol.Types.CHAR)
		{
			throw new ErrorSemantico("char2int solo acepta caracteres");
		}
	}
|   t=<tID> ((<tAP> (function_call(at)) <tCP> {

	}))?  
	{
		try
		{
			S = st.getSymbol(t.image);
			// System.err.println("Encontrado " + S);
			// System.err.println("Token id " + t.image);
			// System.err.println("Function call");
			//at.type = S.type;
			at.code = (t.image);
			at.nivel = st.level;
			att.atts.add(at);
			String _code="";
			int size = at.atts.size();

			//Comprobar parametros (PENDIENTE)
			for (int i = 0; i < size; i++) {
				Attributes a = at.atts.get(i);
				_code += a.code;
				if (i < size - 1) { // if this is not the last element
					_code += ",";
				}
			}
			att.code = _code;

			if(att.type==Symbol.Types.UNDEFINED)
			{
				att.type = S.type;

				if(S.type==Symbol.Types.ARRAY)
				{
					att.type = ((SymbolArray)S).baseType;
				}
				
				if(S.type==Symbol.Types.FUNCTION)
				{
					att.type = ((SymbolFunction)S).returnType;
				}

				//.println(att.type+" "+S.name);
			}

			at = new Attributes();

			
			// else if(att.type!=at.type)
			// {
			// 	throw new ErrorSemantico("Error de tipos");
			// }
			
			// System.err.println("Añadido " + at);
			
		}
		catch(SymbolNotFoundException ex)
		{
			throw new ErrorSemantico(t.image + " no existe.");
		}

	}
|   t= <tCONST_INT> 
    {
		at.type = Symbol.Types.INT;
		at.code = (t.image);
		at.nivel = st.level;
		att.atts.add(at);
		//att.type = at.type;
		
		if(att.type==Symbol.Types.UNDEFINED)
		{
			att.type = at.type;
		}

		//at = new Attributes();
		// else if(att.type!=at.type)
		// {
		// 	throw new ErrorSemantico("Error de tipos");
		// }
		// System.err.println("Añadido " + at);
		
	}
|   t= <tCONST_CHAR> 
	{
		//CAMBIARLO INVOCACION A FUNCION
		at.type = Symbol.Types.CHAR;
		at.code = (t.image);
		at.nivel = st.level;
		att.atts.add(at);
		//att.type = at.type;
		//at = new Attributes();
		if(att.type==Symbol.Types.UNDEFINED)
		{
			att.type = at.type;
		}
		// else if(att.type!=at.type)
		// {
		// 	throw new ErrorSemantico("Error de tipos");
		// }
		// System.err.println("Añadido " + at);
		
	}
|   t= <tCONST_STRING> 
	{
		at.type = Symbol.Types.STRING;
		at.code = (t.image);
		at.nivel = st.level;
		att.atts.add(at);
		att.type = at.type;
		//at = new Attributes();
		/*if(atts.type==Symbol.Types.UNDEFINED)
		{
			atts.type = at.type;
		}
		else if(atts.type!=at.type)
		{
			throw new ErrorSemantico("Error de tipos");
		}*/
		// System.err.println("Añadido " + at);
		
	}
|   t= <tTRUE>	
	{
		at.type = Symbol.Types.BOOL;
		at.code = "true";
		at.nivel = st.level;
		att.atts.add(at);
		//att.type = at.type;
		//at = new Attributes();
		if(att.type==Symbol.Types.UNDEFINED)
		{
			att.type = at.type;
		}
		// else if(att.type!=at.type)
		// {
		// 	throw new ErrorSemantico("Error de tipos");
		// }
		// System.err.println("Añadido " + at);
		
	}
|   t= <tFALSE> 
	{
		at.type = Symbol.Types.BOOL;
		at.code = "false";
		at.nivel = st.level;
		att.atts.add(at);
		//att.type = at.type;
		//at = new Attributes();
		if(att.type==Symbol.Types.UNDEFINED)
		{
			att.type = at.type;
		}
		// else if(att.type!=at.type)
		// {
		// 	throw new ErrorSemantico("Error de tipos");
		// }

		// System.err.println("Añadido " + at);
		
	}

}


void function_call(Attributes att) :
{ 
	Attributes at = new Attributes();
  	// Attributes att2 = new Attributes();
}
{
 ( expresion(at)
 {
	//att.type = att2.type;
	att.atts.add(at);
	//att.type = at.type;
	at = new Attributes();
 	// System.err.println("Añadido " + att);
 	// System.err.println("Añadido " + att);
 } 
 ((<tCOMA>) expresion(at)
 {
	att.atts.add(at);
	//att.type = at.type;
	at = new Attributes();
	// System.err.println("Añadido " + att);
	// System.err.println("Añadido " + att);
}
)* 
 ) 
 {
	String _code="";
		int size = att.atts.size();
		for (int i = 0; i < size; i++) {
			Attributes a = att.atts.get(i);
			_code += a.code;
			if (i < size - 1) { // if this is not the last element
				_code += ",";
			}
		}
		att.code = _code;	
 }
}


void tipo_variable(Attributes atTypes, Attributes atIsArray):
{ 
	Token i;
}
{
	< tARRAY >
	<tAP>
	i = < tCONST_INT >
		{
			atTypes.inicio = Integer.parseInt(i.image);
			
			//at.parList.add(new Symbol(i.image,Symbol.Types.INT));
			
		}
	("..")
	i = < tCONST_INT >
		{
			atTypes.fin = Integer.parseInt(i.image);
			// at.parList.add(new Symbol(i.image,Symbol.Types.INT));
			atTypes.type = Symbol.Types.ARRAY;
		}
	<tCP>
	 <tOF> tipo_variable_simple(atIsArray)
|   tipo_variable_simple(atTypes)
}

void tipo_variable_simple(Attributes at):
{

}
{
		< tBOOL > 
			{
				at.type = Symbol.Types.BOOL;
			}
	|	< tCHAR >
			{
				at.type = Symbol.Types.CHAR;
			}
	|	< tINT >
			{
				at.type = Symbol.Types.INT;
			}
}

