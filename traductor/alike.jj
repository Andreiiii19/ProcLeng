//*****************************************************************
// File:   cl.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
// Date:   julio 2023
// Coms:   compilar mediante "ant"
//*****************************************************************

options {
	IGNORE_CASE = true;
	COMMON_TOKEN_ACTION = false;
}

PARSER_BEGIN(alike)

package traductor;

//...

import lib.symbolTable.*;
import lib.attributes.*;
import lib.symbolTable.exceptions.*;
import java.util.ArrayList;
import lib.errores.*;
import lib.tools.SemanticFunctions;

public class alike { 


	static SymbolTable st;

	private static void initSymbolTable() {
		boolean b;
		String[] palsRes = {
	    	"array","boolean","character","integer","procedure","if","then","elsif","else","end",
			"while","loop","begin","ref","of","is","not","put_line","put","return","and","or",
			"mod","skip_line","function","null","get","true","false","int2char","char2int"
		};

		st = new SymbolTable();

		st.insertReservedWords(palsRes);
	}

   public static void main(String[] args) {
	   alike parser = null;
	   SemanticFunctions sf = new SemanticFunctions();
	   initSymbolTable();
	   
	   try {
		   if(args.length == 0) {
			   parser = new alike(System.in);
		   }
		   else {
			   parser = new alike(new java.io.FileInputStream(args[0]));
		   }
		   //Programa es el símbolo inicial de la gramática
		   parser.Programa();
		   System.out.println(st.toString());
		   //...
		   System.out.println("***** Análisis terminado con éxito *****");
	   }
	   catch (java.io.FileNotFoundException e) {
		   System.err.println ("Fichero " + args[0] + " no encontrado.");
	   }
	   catch (TokenMgrError e) {
		   System.err.println("LEX_ERROR: " + e.getMessage());
	   }
	   catch (ParseException e) {
            System.err.println("PARSER_ERROR: " + e.getMessage());
        }
	   //...
   }
}
PARSER_END(alike)

TOKEN_MGR_DECLS : {
	static void CommonTokenAction(Token token) {
		System.err.println("(" + token.beginLine + ", "
					+ token.beginColumn + "): "+ alikeConstants.tokenImage[token.kind] + " " + token.image);
	}

}

SPECIAL_TOKEN : {
	< tCOMMENT: (<COMMENT>) >
}

TOKEN : {
	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|	< #CHAR: (~["\\"]) >
|	< #STRING: (~["\\","\""]|("\"\""))+ >
|	< #COMMENT: ("--")(~["\n"])*("\n") >
}

TOKEN : {
	< tBOOL: "boolean" >
|	< tCHAR: "character" >
|	< tINT: "integer" >
|	< tARRAY: "array" >
|	< tPROC: "procedure" >
|	< tIF:	"if" >
|	< tTHEN: "then" >
|	< tELSIF: "elsif" >
|	< tELSE: "else" >
|	< tENDIF: "end"(" ")+"if"> 
| 	< tEND: "end" >
|	< tWHILE: "while" >
|	< tLOOP: "loop" >
|	< tENDLOOP: "end loop" >
|	< tBEGIN: "begin" >
|	< tREF: "ref" >
|	< tOF: "of" >
|	< tIS: "is" >
|	< tNOT: "not" >
| 	< tPC: ";" >
|	< tPLINE: "put_line" >
|	< tPUT: "put" >
|	< tRETURN: "return" >
|	< tAP: "(" >
|	< tCP: ")" >
|	< tASIG: ":=" >
|	< tGE: ">=" >
|	< tLE: "<=" >
|	< tNEQ: "/=" >
|	< tEQ: "=" >
|	< tGT: ">" >
|	< tLS: "<" >
|	< tDP: ":" >
|	< tAND: "and" >
|	< tOR: "or" >
|	< tADD: "+" >
|	< tSUB: "-" >
|	< tDIV: "/" >
|	< tMUL: "*" >
|	< tCOMA: "," >
|	< tMOD: "mod" >
|	< tSKIP: "skip_line" >
|	< tFUNC : "function" >
|	< tNULL : "null" >
|	< tGET : "get" >
|	< tTRUE : "true" >
|	< tFALSE : "false" >
|	< tINT2CHAR : "int2char" >
|	< tCHAR2INT : "char2int" >
|	< tCONST_CHAR : ("'")(< CHAR >)("'") >
|	< tCONST_INT : ("-")?(< DIGIT >)+ >
|	< tCONST_STRING : ("\"")(< STRING >)*("\"") >
| 	< tID: (< LETTER >| "_")+(< DIGIT >| "_" | < LETTER >)* > 
}

SKIP : 
{
	" "
|	"\t"
|	"\n"
|	"\r" 
}





//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void Programa():
{
	Token name;
	Attributes at = new Attributes();
} 
{
	<tPROC>
	name = <tID>
	(<tAP> parametros_formales(at) <tCP>)?
	<tIS>
	( declaracion_variables() )?
	( (declaracion_procs_funcs())+ )?
	<tBEGIN>
	instrucciones()
	<tEND>
	<tPC>
}

void declaracion_procedimiento():
{
	Token name;
	Attributes att = new Attributes();
}
{
	name = cabecera_procedimiento(att)
	( declaracion_variables() )?
	( declaracion_procs_funcs() )?
	<tBEGIN>
	instrucciones()
	<tEND>
	<tPC> 
	{
		System.err.println("Bloque" + name.image + "terminado \n" + st.toString());
		st.removeBlock();
	}
}

void declaracion_funcion():
{
	Attributes atType = new Attributes();
	Attributes atIsArray = new Attributes();
	Attributes atts = new Attributes();
	Token name;
}
{
	name = cabecera_funcion(atType,atIsArray,atts)
	( declaracion_variables() )?
	( declaracion_procs_funcs() )?
	<tBEGIN>
	{
		
	}
	instrucciones()
	<tEND>
	<tPC>
	{
		System.err.println("Bloque " + name.image + " terminado \n"+ st.toString());
		st.removeBlock();
		if(atType.type == Symbol.Types.ARRAY)
		{
			throw new ErrorSemantico("No se permiten funciones con retorno de vectores");
		}
	}
}

void declaracion_procs_funcs():
{}
{
	declaracion_procedimiento()
	| declaracion_funcion()
}

void instrucciones():
{}
{
	(instruccion()(";"))+
}


void declaracion_variables():
{

}
{
	( declaracion_var() ";")+
}

ArrayList<Symbol> declaracion_var():
{
	Attributes atType = new Attributes();
	Attributes atIsArray = new Attributes();
	ArrayList<Token> tokens;
	ArrayList<Symbol> symbols = new ArrayList<Symbol>();
}
{
		tokens = lista_ids()
		<tDP>
		(	
		<tREF>
			{
				atType.parClass = Symbol.ParameterClass.REF;
			}
		)?
		tipo_variable(atType,atIsArray)
		{	
			if(atType.parClass==Symbol.ParameterClass.NONE)atType.parClass=Symbol.ParameterClass.VAL;
			for(Token t : tokens)
			{
				Symbol S = null;

				

				if(atType.type == Symbol.Types.BOOL) S = new SymbolBool(t.image, atType.parClass);
				if(atType.type == Symbol.Types.CHAR) S = new SymbolChar(t.image, atType.parClass);
				if(atType.type == Symbol.Types.INT) S = new SymbolInt(t.image, atType.parClass);
				if(atType.type == Symbol.Types.ARRAY) 
				{
					S = new SymbolArray(t.image, atType.inicio,atType.fin,atIsArray.type,atType.parClass);
				}

				symbols.add(S);
				
				try {
					st.insertSymbol(S);
				} catch (AlreadyDefinedSymbolException e)
				{
					System.err.println("Error semantico. Simbolo ya existente");
				}
			}

			return symbols;
		}
}

ArrayList<Token> lista_ids():
{
	ArrayList<Token> tokens = new ArrayList<Token>();
	Token t;
}
{
	(
		t=<tID>
			{
				if(!st.isReservedWord(t.image))
				{
					tokens.add(t);
				}
				else
				{
					throw new ErrorSemantico("ID no valido. Es una palabra reservada");
				}
			}
	)
	(
		<tCOMA>
		t=<tID>
			{
				if(!st.isReservedWord(t.image)) tokens.add(t);
				else throw new ErrorSemantico("ID no valido. Es una palabra reservada");
			}
	)*
		{
			return tokens;
		}
}

void lista_ids_o_string_o_inv():
{

}
{
	expresion() (<tCOMA> expresion())*
}


Token cabecera_procedimiento(Attributes att):
{
	Token name;
}
{
	<tPROC>
	name = <tID>
	{
		try {
			Symbol S = new SymbolProcedure(name.image,att.parList);
			st.insertSymbol(S);
			st.insertBlock();
		}catch (AlreadyDefinedSymbolException ex)
		{
			System.err.println("Error semantico. Simbolo ya existente");
		}
	}
	(<tAP> 
	parametros_formales(att)
	<tCP>)?
	<tIS>
	{
		return name;
	}
}

Token cabecera_funcion(Attributes atType,Attributes atIsArray,Attributes atts):
{
	Token name;
}
{
	<tFUNC>
	name = <tID>
	{
		try{ 
			Symbol S = new SymbolFunction(name.image,atts.parList,atType.type);
			st.insertSymbol(S);
			st.insertBlock();
		} catch (AlreadyDefinedSymbolException ex)
		{
			System.err.println("Error semantico. Simbolo ya existente");
		}
		
	}
	(<tAP> parametros_formales(atts) <tCP>)?
	<tRETURN>
	tipo_variable(atType,atIsArray)
	<tIS>
	{
		return name;
	}
}

void parametros_formales(Attributes att): 
{
	ArrayList<Symbol> symbols;
}
{
	symbols = declaracion_var()
	{
		// try {
			for(Symbol S : symbols)
			{
				att.parList.add(S);
		// 		st.insertSymbol(S);
			}
		// } catch (AlreadyDefinedSymbolException ex)
		// {
		// 	System.err.println("Error semantico. Simbolo ya existente");
		// }
	}
	(<tPC> 
	symbols = declaracion_var()
	{
		for(Symbol S : symbols)
		{
			att.parList.add(S);
			// st.insertSymbol(S);
		}
	}
	)*
}


void instruccion() :
{

} 
{
		inst_leer()
	|   inst_saltar_linea()
	|	inst_escribir()
	|   inst_escribir_linea()
	|   inst_invocacion_o_asignacion()
	|   inst_if()
	|   inst_while()
	|   inst_return()
	|   inst_null()
}

void inst_leer():{}{<tGET> <tAP> lista_ids() <tCP>}

void inst_saltar_linea():{}{<tSKIP>}

void inst_escribir():{}{<tPUT> <tAP> lista_ids_o_string_o_inv()  <tCP>}

void inst_escribir_linea():{}{<tPLINE> ((<tAP> lista_ids_o_string_o_inv() <tCP>))?}

void inst_invocacion_o_asignacion():{}{
	<tID> (<tAP> (function_call()) <tCP>)? (<tASIG> expresion())?
}


void inv_funcion():{}{(expresion() (<tCOMA> expresion())*)}

void inst_if():{}{<tIF> expresion() <tTHEN> instrucciones() ((<tELSIF> expresion() <tTHEN> instrucciones())* (<tELSE> instrucciones())?) <tENDIF>} 

void inst_while():{}{<tWHILE> expresion() <tLOOP> instrucciones() <tENDLOOP>}

void inst_return():{}{<tRETURN> expresion()}

void inst_null():{}{<tNULL>}


Attributes expresion():
{
	Attributes att=new Attributes(),att2 = new Attributes();
}
{
    relacion(att)
	( ((<tAND> | <tOR>) relacion(att2)
	{
		// if(att.type!=Symbol.Types.BOOL||att2.type!=Symbol.Types.BOOL)
		// {
		// 	throw new ErrorSemantico("(and,or)) solo acepta booleanos");
		// }
	}
	)+ )?
	{
		// ( 2+3+4) + 5 + (2+3)
		// Expresion
		//  (2+3+4)
		//   5
		//  (2+3)
		System.err.println("Expresion: " + att);	
		return att;
	}
}

void relacion(Attributes att):
{
	//Attributes atTypes = new Attributes();
	Attributes att2 = new Attributes();
}
{
    expresion_simple(att)
 	( operador_relacional() expresion_simple(att2) )?
}

void operador_relacional():
{
	
}
{    
	<tEQ>    // Char,bool,int
	| <tLS>  // Int
	| <tGT>  // Int
	| <tLE>  // Int
	| <tGE>  // Int
	| <tNEQ> // Char,bool,int
}

void expresion_simple(Attributes att):
{
	Attributes att2 = new Attributes();
}
{
	( <tADD> |	<tSUB> )? 
    termino(att)
	( ( <tADD> | <tSUB> ) termino(att2) 
	{
		// if(att.type!=Symbol.Types.INT||att2.type!=Symbol.Types.INT)
		// {
		// 	throw new ErrorSemantico("(+,-) solo acepta integers");
		// }
	})*
}

void termino(Attributes att):
{
	Attributes att2 = new Attributes();
}
{
    factor(att) 
	( operador_multiplicativo() factor(att2)
	{
		// if(att.type!=Symbol.Types.INT||att2.type!=Symbol.Types.INT)
		// {
		// 	throw new ErrorSemantico("(*,%,/) solo acepta integers");
		// }
	}
	
	)*
}

void operador_multiplicativo():
{}
{
    <tMUL> | <tMOD> | <tDIV>
}

void factor(Attributes att):
{}
{
    primario(att)
|   <tNOT>  primario(att)
	{
		// if(att.type!=Symbol.Types.BOOL)
		// {
		// 	throw new ErrorSemantico("not solo acepta booleanos");
		// }
	}
}

void primario(Attributes att) :
{ 
	Attributes at = new Attributes();
	Token t;
	Symbol S;
}
{
	<tAP> at = expresion() <tCP> 
	{
		att.atts.add(at);
	}
|   <tINT2CHAR> <tAP> at = expresion() <tCP> 
	{
		for (Attributes a : at.atts)
		{
			if(a.type!=Symbol.Types.INT)
			{
				throw new ErrorSemantico("int2char solo acepta enteros");
			}
		}
	}
|   <tCHAR2INT> <tAP> at = expresion() <tCP> 
{
	for (Attributes a : at.atts)
	{
		if(a.type!=Symbol.Types.CHAR)
		{
			throw new ErrorSemantico("char2int solo acepta caracteres");
		}
	}
}
|   t=<tID> (<tAP> (function_call()) <tCP>)?  
	{
		try
		{
			S = st.getSymbol(t.image);
			System.err.println("Encontrado " + S);
			at.type = S.type;
			at.code = (t.image);
			at.nivel = st.level;
			att.atts.add(at);

			if(atts.type==Symbol.Types.UNDEFINED)
			{
				atts.type = at.type;
			}
			else if(atts.type!=at.type)
			{
				throw new ErrorSemantico("Error de tipos");
			}
			
			System.err.println("Añadido " + at);
			
		}
		catch(SymbolNotFoundException ex)
		{
			throw new ErrorSemantico(t.image + " no existe.");
		}

	}
|   t= <tCONST_INT> 
    {
		at.type = Symbol.Types.INT;
		at.code = (t.image);
		at.nivel = st.level;
		att.atts.add(at);
		if(atts.type==Symbol.Types.UNDEFINED)
		{
			atts.type = at.type;
		}
		else if(atts.type!=at.type)
		{
			throw new ErrorSemantico("Error de tipos");
		}
		System.err.println("Añadido " + at);
		
	}
|   t= <tCONST_CHAR> 
	{
		//CAMBIARLO INVOCACION A FUNCION
		at.type = Symbol.Types.CHAR;
		at.code = (t.image);
		at.nivel = st.level;
		att.atts.add(at);
		if(atts.type==Symbol.Types.UNDEFINED)
		{
			atts.type = at.type;
		}
		else if(atts.type!=at.type)
		{
			throw new ErrorSemantico("Error de tipos");
		}
		System.err.println("Añadido " + at);
		
	}
|   t= <tCONST_STRING> 
	{
		at.type = Symbol.Types.STRING;
		at.code = (t.image);
		at.nivel = st.level;
		att.atts.add(at);
		/*if(atts.type==Symbol.Types.UNDEFINED)
		{
			atts.type = at.type;
		}
		else if(atts.type!=at.type)
		{
			throw new ErrorSemantico("Error de tipos");
		}*/
		System.err.println("Añadido " + at);
		
	}
|   t= <tTRUE>	
	{
		at.type = Symbol.Types.BOOL;
		at.code = "true";
		at.nivel = st.level;
		att.atts.add(at);
		if(atts.type==Symbol.Types.UNDEFINED)
		{
			atts.type = at.type;
		}
		else if(atts.type!=at.type)
		{
			throw new ErrorSemantico("Error de tipos");
		}
		System.err.println("Añadido " + at);
		
	}
|   t= <tFALSE> 
	{
		at.type = Symbol.Types.BOOL;
		at.code = "false";
		at.nivel = st.level;
		att.atts.add(at);

		if(atts.type==Symbol.Types.UNDEFINED)
		{
			atts.type = at.type;
		}
		else if(atts.type!=at.type)
		{
			throw new ErrorSemantico("Error de tipos");
		}

		System.err.println("Añadido " + at);
		
	}

}

void variable() :
{ }
{
	indexacion() 
}

void function_call() :
{ }
{
 (expresion() ((<tCOMA>) expresion())* )
}

void indexacion():
{ 
	Attributes at = new Attributes();
}
{
	expresion_simple(at)
}

void tipo_variable(Attributes atTypes, Attributes atIsArray):
{ 
	Token i;
}
{
	< tARRAY >
	<tAP>
	i = < tCONST_INT >
		{
			atTypes.inicio = Integer.parseInt(i.image);
			
			//at.parList.add(new Symbol(i.image,Symbol.Types.INT));
			
		}
	("..")
	i = < tCONST_INT >
		{
			atTypes.fin = Integer.parseInt(i.image);
			// at.parList.add(new Symbol(i.image,Symbol.Types.INT));
			atTypes.type = Symbol.Types.ARRAY;
		}
	<tCP>
	 <tOF> tipo_variable_simple(atIsArray)
|   tipo_variable_simple(atTypes)
}

void tipo_variable_simple(Attributes at):
{

}
{
		< tBOOL > 
			{
				at.type = Symbol.Types.BOOL;
			}
	|	< tCHAR >
			{
				at.type = Symbol.Types.CHAR;
			}
	|	< tINT >
			{
				at.type = Symbol.Types.INT;
			}
}

